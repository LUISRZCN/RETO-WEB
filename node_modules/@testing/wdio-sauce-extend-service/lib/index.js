"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const util_1 = require("util");
const fs_1 = require("fs");
const path_1 = require("path");
const request_1 = require("request");
const os_1 = require("os");
const exists = util_1.promisify(fs_1.exists);
function upload(appPath, url, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = {
            url,
            formData: {
                payload: fs_1.createReadStream(appPath),
                name
            }
        };
        return new Promise((end, fail) => request_1.post(options, (error, httpRequest) => {
            const { statusCode, statusMessage } = httpRequest || {};
            const isError = !statusCode || statusCode >= 400;
            return isError ? fail(statusMessage) : end(null);
        }));
    });
}
module.exports = class SauceExtendService {
    onPrepare(config, capabilities) {
        return __awaiter(this, void 0, void 0, function* () {
            const caps = Array.isArray(capabilities) ? capabilities : Object.values(capabilities);
            const build = process.env.BUILD_TAG || `${os_1.userInfo().username}@${os_1.hostname()}@${os_1.platform()} ${config.user} ${new Date().toUTCString()}`;
            console.log('Sauce Labs build name: ' + build);
            caps.forEach(capability => {
                const options = Object.assign({ build, 'job_name': process.env.JOB_NAME, 'git_commit': process.env.GIT_COMMIT, 'git_url': process.env.GIT_URL, 'git_branch': process.env.GIT_BRANCH, 'build_url': process.env.BUILD_URL, public: 'private', tunnelIdentifier: capability['tunnelIdentifier'] }, capability['sauce:options']);
                if (capability.deviceName) {
                    Object.keys(options)
                        .filter(key => !capability[key])
                        .forEach(key => capability[key] = options[key]);
                }
                else {
                    capability['sauce:options'] = options;
                    delete capability['tunnelIdentifier'];
                }
            });
            if (!config.hostname)
                return;
            yield Promise.all(caps.map((capability) => __awaiter(this, void 0, void 0, function* () {
                if (this._isAppFile(capability)) {
                    const appPath = capability.app || capability['appium:app'];
                    const url = this._getApiUrl(config);
                    const appName = this._getAppName(capability);
                    try {
                        const errorMessage = yield upload(appPath, url, appName);
                        if (errorMessage) {
                            throw errorMessage;
                        }
                        console.log(`App ${appName} successfully uploaded`);
                        if (capability.app) {
                            capability.app = `sauce-storage:${appName}`;
                        }
                        else {
                            capability['appium:app'] = `sauce-storage:${appName}`;
                        }
                    }
                    catch (error) {
                        console.log(error);
                        throw error;
                    }
                }
            })));
        });
    }
    _getApiUrl(config) {
        const { user, key, region } = config || {};
        return `https://${user}:${key}@api.${this._getRegion(region)}.saucelabs.com/v1/storage/upload?overwrite=true`;
    }
    _getAppName(capability) {
        return path_1.basename(capability.app || capability['appium:app']).replace(/\./, Math.random().toString().slice(2) + '.');
    }
    _getRegion(region) {
        const defaultRegion = 'eu';
        const regions = {
            eu: 'eu-central-1',
            us: 'us-west-1'
        };
        return regions[region] || regions[defaultRegion];
    }
    _isAppFile(capability) {
        return __awaiter(this, void 0, void 0, function* () {
            const isApp = capability.app && (yield exists(capability.app));
            const isAppiumApp = capability['appium:app'] && (yield exists(capability['appium:app']));
            return isApp || isAppiumApp;
        });
    }
};
//# sourceMappingURL=index.js.map