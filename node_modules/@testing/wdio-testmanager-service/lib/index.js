"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger_1 = require("@wdio/logger");
const log = logger_1.default('testmanager-service');
function escape(s) {
    return s.replace(/\//g, '~~');
}
let allure;
try {
    allure = require("@wdio/allure-reporter").default;
}
catch (e) { }
let cucumber;
try {
    cucumber = require('cucumber');
}
catch (e) { }
let wdioCucumberReporter;
try {
    wdioCucumberReporter = require('wdio-cucumberjs-json-reporter').default;
}
catch (e) { }
if (!allure && !wdioCucumberReporter) {
    console.log("No allure or cucumber reporters were found. If you send results to TestManager this may lead to duplicate tests");
}
module.exports = class TestManagerService {
    constructor(config) {
        this.reloadPromise = Promise.resolve();
        this._customTestName = config === null || config === void 0 ? void 0 : config.customTestName;
    }
    before() {
        var _a, _b;
        this._enabled =
            (((_b = (_a = browser === null || browser === void 0 ? void 0 : browser.config) === null || _a === void 0 ? void 0 : _a.hostname) === null || _b === void 0 ? void 0 : _b.indexOf('galatea')) >= 0 &&
                !!process.env.TEST_MANAGER_EXECUTION_ID) ||
                process.env.TESTMANAGER_REPORTING_ENABLED === 'true';
        if (!this._enabled) {
            log.info("TestManager realtime reporting disabled");
            return;
        }
        const reloadSession = browser.reloadSession.bind(browser);
        browser.overwriteCommand("reloadSession", () => __awaiter(this, void 0, void 0, function* () {
            let resolve;
            this.reloadPromise = new Promise(res => resolve = res);
            yield reloadSession();
            resolve();
        }));
    }
    beforeSuite(suite) {
        if (!this._enabled)
            return;
        this._suiteTitle = suite.title;
    }
    beforeTest(test) {
        if (!this._enabled)
            return;
        if (this._suiteTitle === 'Jasmine__TopLevel__Suite') {
            this._suiteTitle = test.fullName.slice(0, test.fullName.indexOf(test.description || '') - 1);
        }
        this._testName = (this._customTestName ? this._customTestName({ test }) :
            /**
             * Jasmine
             */
            test.fullName ||
                /**
                 * Mocha
                 */
                `${test.parent} - ${test.title}`);
        this._testTags = undefined;
        this.createTest();
    }
    afterTest(test) {
        if (!this._enabled)
            return;
        this.setTestResult({
            result: test.passed ? 'Pass' : 'Fail'
        });
    }
    beforeFeature(_uri, { document: { feature } }) {
        if (!this._enabled)
            return;
        const self = this;
        cucumber && cucumber.Before(function () {
            self._scenario = this;
        });
        this._suiteTitle = feature.name;
    }
    beforeScenario(uri, feature, scenario) {
        if (!this._enabled)
            return;
        this._testName = this._customTestName ? this._customTestName({ uri, feature, scenario })
            : scenario.name || 'unknown scenario';
        this._testTags = scenario.tags.map(tag => tag.name);
        this.createTest();
    }
    afterScenario(_uri, _feature, _scenario, result, _sourceLocation) {
        if (!this._enabled)
            return;
        const testId = this.setTestResult({
            message: (result.exception && result.exception.stack),
            result: result.status === 'passed' ? 'Pass' : 'Fail'
        });
        if (testId) {
            const attachment = `{"testId":${testId}}`;
            this._scenario && this._scenario.attach(`{"galatea:testmanager": ${attachment}}`, 'application/json');
            allure && allure.addEnvironment("galatea:testmanager", attachment);
            wdioCucumberReporter && wdioCucumberReporter.attach(Buffer.from(`{"galatea:testmanager": ${attachment}}`).toString('base64'), 'application/json');
        }
    }
    createTest() {
        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            yield this.reloadPromise;
            log.info("Creting test in TestManager");
            log.info(JSON.stringify(this.buildStartTestData()));
            browser.execute('galatea:' + JSON.stringify({
                type: 'testmanager',
                data: this.buildStartTestData()
            }));
        }));
    }
    buildStartTestData() {
        return {
            eid: process.env.TEST_MANAGER_EXECUTION_ID,
            namespace: process.env.TEST_MANAGER_NAMESPACE,
            app: escape(process.env.TEST_MANAGER_APPLICATION),
            env: escape(process.env.TEST_MANAGER_ENV),
            branch: escape(process.env.TEST_MANAGER_BRANCH),
            tid: process.env.TEST_MANAGER_TID,
            name: this._testName,
            suite: this._suiteTitle,
            type: process.env.TM_TEST_TYPE,
            framework: process.env.TM_TEST_FRAMEWORK,
            tags: this._testTags
        };
    }
    setTestResult(data) {
        const { testId } = browser.execute('galatea:' + JSON.stringify({
            type: 'testmanager',
            data
        }));
        return testId;
    }
};
//# sourceMappingURL=index.js.map