"use strict";
exports.__esModule = true;
exports.buildPolyfills = void 0;
var tslib_1 = require("tslib");
function buildPolyfills() {
    var polyfills = "\n    var __spreadArrays = " + tslib_1.__spreadArrays + ";\n    (" + assign + ")();\n  ";
    if (browser.capabilities.browserName === 'internet explorer') {
        polyfills += "\n      (" + arrays + ")();\n      (" + elementMatches + ")();\n    ";
    }
    return polyfills;
}
exports.buildPolyfills = buildPolyfills;
function assign() {
    window.__assign = (this && this.__assign) || function () {
        window.__assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return window.__assign.apply(this, arguments);
    };
}
function elementMatches() {
    /**
     * Element.matches() polyfill (simple version)
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
     */
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
}
function arrays() {
    /**
     * Array.prototype.find() polyfill
     * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
     * @author Chris Ferdinandi
     * @license MIT
     */
    if (!Array.prototype.find) {
        Array.prototype.find = function (callback) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(callback) is false, throw a TypeError exception.
            if (typeof callback !== 'function') {
                throw new TypeError('callback must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(callback, T, « kValue, k, O »)).
                // d. If testResult is true, return kValue.
                var kValue = o[k];
                if (callback.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return undefined.
            return undefined;
        };
    }
    /**
     * Array.filter() polyfill
     */
    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
    if (!Array.prototype.filter)
        Array.prototype.filter = function (func, thisArg) {
            'use strict';
            if (!((typeof func === 'Function' || typeof func === 'function') && this))
                throw new TypeError();
            var len = this.length >>> 0, res = new Array(len), // preallocate array
            t = this, c = 0, i = -1;
            if (thisArg === undefined)
                while (++i !== len)
                    // checks to see if the key was set
                    if (i in this)
                        if (func(t[i], i, t))
                            res[c++] = t[i];
                        else
                            while (++i !== len)
                                // checks to see if the key was set
                                if (i in this)
                                    if (func.call(thisArg, t[i], i, t))
                                        res[c++] = t[i];
            res.length = c; // shrink down array to proper size
            return res;
        };
    // Production steps of ECMA-262, Edition 5, 15.4.4.19
    // Reference: http://es5.github.io/#x15.4.4.19
    if (!Array.prototype.map) {
        Array.prototype.map = function (callback, thisArg) {
            var T, A, k;
            if (this == null) {
                throw new TypeError(' this is null or not defined');
            }
            // 1. Let O be the result of calling ToObject passing the |this|
            //    value as the argument.
            var O = Object(this);
            // 2. Let lenValue be the result of calling the Get internal
            //    method of O with the argument "length".
            // 3. Let len be ToUint32(lenValue).
            var len = O.length >>> 0;
            // 4. If IsCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
            if (arguments.length > 1) {
                T = thisArg;
            }
            // 6. Let A be a new array created as if by the expression new Array(len)
            //    where Array is the standard built-in constructor with that name and
            //    len is the value of len.
            A = new Array(len);
            // 7. Let k be 0
            k = 0;
            // 8. Repeat, while k < len
            while (k < len) {
                var kValue, mappedValue;
                // a. Let Pk be ToString(k).
                //   This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty internal
                //    method of O with argument Pk.
                //   This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {
                    // i. Let kValue be the result of calling the Get internal
                    //    method of O with argument Pk.
                    kValue = O[k];
                    // ii. Let mappedValue be the result of calling the Call internal
                    //     method of callback with T as the this value and argument
                    //     list containing kValue, k, and O.
                    mappedValue = callback.call(T, kValue, k, O);
                    // iii. Call the DefineOwnProperty internal method of A with arguments
                    // Pk, Property Descriptor
                    // { Value: mappedValue,
                    //   Writable: true,
                    //   Enumerable: true,
                    //   Configurable: true },
                    // and false.
                    // In browsers that support Object.defineProperty, use the following:
                    // Object.defineProperty(A, k, {
                    //   value: mappedValue,
                    //   writable: true,
                    //   enumerable: true,
                    //   configurable: true
                    // });
                    // For best browser support, use the following:
                    A[k] = mappedValue;
                }
                // d. Increase k by 1.
                k++;
            }
            // 9. return A
            return A;
        };
    }
    if (!Array.prototype.reduce) {
        Array.prototype.reduce = function (fun /*, inicial*/) {
            var longitud = this.length;
            if (typeof fun != 'function')
                throw new TypeError();
            // no se devuelve ningún valor si no hay valor inicial y el array está
            // vacío
            if (longitud == 0 && arguments.length == 1)
                throw new TypeError();
            var indice = 0;
            if (arguments.length >= 2) {
                var rv = arguments[1];
            }
            else {
                do {
                    if (indice in this) {
                        rv = this[indice++];
                        break;
                    }
                    // si el array no contiene valores, no existe valor inicial a devolver
                    if (++indice >= longitud)
                        throw new TypeError();
                } while (true);
            }
            for (; indice < longitud; indice++) {
                if (indice in this)
                    rv = fun.call(null, rv, this[indice], indice, this);
            }
            return rv;
        };
    }
    // Pasos de producción de ECMA-262, Edición 6, 22.1.2.1
    // Referencia: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from
    if (!Array.from) {
        Array.from = (function () {
            var toStr = Object.prototype.toString;
            var isCallable = function (fn) {
                return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
            };
            var toInteger = function (value) {
                var number = Number(value);
                if (isNaN(number)) {
                    return 0;
                }
                if (number === 0 || !isFinite(number)) {
                    return number;
                }
                return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var toLength = function (value) {
                var len = toInteger(value);
                return Math.min(Math.max(len, 0), maxSafeInteger);
            };
            // La propiedad length del método from es 1.
            return function from(arrayLike /*, mapFn, thisArg */) {
                // 1. Deje a C ser el este valor.
                var C = this;
                // 2. Deje que los elementos sean ToObject(arrayLike).
                var items = Object(arrayLike);
                // 3. Retornar IfAbrupt(items).
                if (arrayLike == null) {
                    throw new TypeError("Array.from requiere un objeto array-like - not null or undefined");
                }
                // 4. Si mapfn no está definida, entonces deja que sea false.
                var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                var T;
                if (typeof mapFn !== 'undefined') {
                    // 5. si no
                    // 5. a If IsCallable(mapfn) es false, lanza una excepción TypeError.
                    if (!isCallable(mapFn)) {
                        throw new TypeError('Array.from: si hay mapFn, el segundo argumento debe ser una función');
                    }
                    // 5. b. Si thisArg se suministró, deje que T sea thisArg; si no, deje que T esté indefinido.
                    if (arguments.length > 2) {
                        T = arguments[2];
                    }
                }
                // 10. Let lenValue be Get(items, "length").
                // 11. Let len be ToLength(lenValue).
                var len = toLength(items.length);
                // 13. If IsConstructor(C) is true, then
                // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
                // 14. a. Else, Let A be ArrayCreate(len).
                var A = isCallable(C) ? Object(new C(len)) : new Array(len);
                // 16. Let k be 0.
                var k = 0;
                // 17. Repeat, while k < len… (also steps a - h)
                var kValue;
                while (k < len) {
                    kValue = items[k];
                    if (mapFn) {
                        A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                    }
                    else {
                        A[k] = kValue;
                    }
                    k += 1;
                }
                // 18. Let putStatus be Put(A, "length", len, true).
                A.length = len;
                // 20. Return A.
                return A;
            };
        }());
    }
}
//# sourceMappingURL=index.js.map