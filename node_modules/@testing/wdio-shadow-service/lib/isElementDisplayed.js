"use strict";
exports.__esModule = true;
exports.isElementDisplayed = exports.getConfigFromVisibilityCheckType = exports.VisibilityCheckType = void 0;
/**
 * Indicates how the framework should operate when checking
 * for selectors visibility for an specific pageObject or componentObject
 */
var VisibilityCheckType;
(function (VisibilityCheckType) {
    /**
     * No visibility checks will be performed
     * in addition to the standard `isVisibile`check.
     */
    VisibilityCheckType["WebDriverIoIsVisible"] = "DisplayedInDOM";
    /**
     * The elements,that are placed inside the
     * ViewPort will be checked not to be covered by another element.
     * Note that this check, in shake of speed, is only performed
     * in the top-left, middle-middle, bottom-right spots of the
     * element.
     * Elements outside the viewport will only use the standard
     * `isDisplayed` check.
     */
    VisibilityCheckType["NotCoveredIfInsideViewport"] = "NotCoveredIfInsideViewport";
    /**
     * The elements will be checked to be inside the
     * ViewPort and not to be covered by another element.
     * Note that this check, in shake of speed, is only performed
     * in the top-left, middle-middle, bottom-right spots of the
     * element.
     * Element outside the viewport will be considered to be hidden.
     */
    VisibilityCheckType["NotCoveredAndInsideViewport"] = "NotCoveredAndInsideViewport";
    /**
     * If element is outside the ViewPort it will be scrolled into view
     * prior to the check.
     * The elements will be checked not to be covered by another element.
     * Note that this check, in shake of speed, is only performed
     * in the top-left, middle-middle, bottom-right spots of the
     * element.
     */
    VisibilityCheckType["NotCovered"] = "NotCovered";
})(VisibilityCheckType = exports.VisibilityCheckType || (exports.VisibilityCheckType = {}));
var MAP_CHECK_TYPE_TO_CONFIG = {
    DisplayedInDOM: { enabled: false },
    NotCovered: { autoScroll: true, visibleOutsideViewport: false },
    NotCoveredAndInsideViewport: { autoScroll: false, visibleOutsideViewport: false },
    NotCoveredIfInsideViewport: { autoScroll: false, visibleOutsideViewport: true }
};
function getConfigFromVisibilityCheckType(type) {
    if (typeof type === "string") {
        return MAP_CHECK_TYPE_TO_CONFIG[type];
    }
    else {
        return type;
    }
}
exports.getConfigFromVisibilityCheckType = getConfigFromVisibilityCheckType;
/**
 * check if element is not overlapped by another element or disabled
 * @param  {HTMLElement} elem  element to check
 * @param  {Options} options   Optional options, i.e  {"autoScroll": true, "visibleOutsideViewport": true}
 * @return {Boolean}           false if element is not overlapped
 */
function isElementDisplayed(element, options) {
    if (options === void 0) { options = {}; }
    if ('enabled' in options && !options.enabled) {
        return true;
    }
    options.autoScroll = 'autoScroll' in options ? options.autoScroll : false;
    options.visibleOutsideViewport = 'visibleOutsideViewport' in options ? options.visibleOutsideViewport : true;
    if (typeof document === 'undefined') {
        return true;
    }
    if (!element.getBoundingClientRect || !element.contains || !element.getClientRects || !document.elementFromPoint) {
        return true;
    }
    // Edge before switching to Chromium
    var isOldEdge = !!window.StyleMedia;
    var scrollIntoViewFullSupport = !(window.safari || isOldEdge);
    function isOverlapping(x1, x2, x3, x4) {
        return (x2 > 0) && ((x1 >= x3 && x1 <= x4) ||
            (x2 >= x3 && x2 <= x4) ||
            (x1 <= x3 && x2 >= x4));
    }
    function firstOverlappedPoint(x1, x2, x) {
        if (x1 >= x) {
            return x1;
        }
        else if (x2 >= x) {
            return x;
        }
        else {
            return x1;
        }
    }
    function lastOverlappedPoint(x1, x2, x) {
        if (x2 <= x) {
            return x2;
        }
        else if (x1 <= x) {
            return x;
        }
        else {
            return x2;
        }
    }
    function getViewport() {
        var doc = element.ownerDocument || document;
        return {
            "windowHeight": Math.min(window.innerHeight, doc.documentElement.clientHeight ? doc.documentElement.clientHeight : window.innerHeight, doc.body && document.body.clientHeight ? doc.body.clientHeight : window.innerHeight),
            "windowWidth": Math.min(window.innerWidth, doc.documentElement.clientWidth ? doc.documentElement.clientWidth : window.innerWidth, doc.body && doc.body.clientWidth ? doc.body.clientWidth : window.innerWidth)
        };
    }
    function getOverlappingElementsFromZone(context, left, top, width, height) {
        var points = [];
        var viewport = getViewport();
        var x1 = firstOverlappedPoint(left, left + width, 0);
        var y1 = firstOverlappedPoint(top, top + height, 0);
        var x2 = lastOverlappedPoint(left, left + width, viewport.windowWidth);
        var y2 = lastOverlappedPoint(top, top + height, viewport.windowHeight);
        points.push({
            "x": x1 + ((x2 - x1) > 1 ? 1 : 0),
            "y": y1 + ((y2 - y1) > 1 ? 1 : 0)
        });
        if ((x2 - x1) > 0 && (y2 - y1) > 0) {
            points.push({
                "x": (x1 + ((x2 - x1) / 2)),
                "y": (y1 + ((y2 - y1) / 2))
            });
        }
        points.push({
            "x": x2 - ((x2 - x1) > 1 ? 1 : 0),
            "y": y2 - ((y2 - y1) > 1 ? 1 : 0)
        });
        return points.map(function (point) {
            return context.elementFromPoint(point.x, point.y);
        }).filter(function (i) {
            return i != null;
        });
    }
    // get overlapping element
    function getOverlappingElement(elem, context) {
        context = context || elem.ownerDocument || document;
        var elemDimension = elem.getBoundingClientRect();
        return getOverlappingElementsFromZone(context, elemDimension.left, elemDimension.top, elemDimension.width, elemDimension.height);
    }
    // get overlapping element rects (currently only the first)
    // applicable if element's text is multiline.
    function getOverlappingRects(elem, context) {
        context = context || elem.ownerDocument || document;
        var rects = elem.getClientRects();
        // webdriver clicks on center of the first element's rect (line of text), it might change in future
        var rect = rects[0];
        return rect ?
            getOverlappingElementsFromZone(context, rect.left, rect.top, rect.width, rect.height) :
            [];
    }
    // get overlapping elements
    function getOverlappingElements(elem, context) {
        var elems = getOverlappingElement(elem, context)
            .concat(getOverlappingRects(elem, context));
        return elems.filter(function (elem2, index) {
            return elems.indexOf(elem2) === index;
        });
    }
    // is a node a descendant of a given node
    function nodeContains(elem, otherNode) {
        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used
        if (isOldEdge) {
            var tmpElement = otherNode;
            while (tmpElement) {
                if (tmpElement === elem) {
                    return true;
                }
                tmpElement = tmpElement.parentNode;
                // DocumentFragment / ShadowRoot polyfill like ShadyRoot
                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {
                    tmpElement = tmpElement.host;
                }
            }
            return false;
        }
        return elem.contains(otherNode);
    }
    // is one of overlapping elements the `elem` or one of its child
    function isOverlappingElementMatch(elementsFromPoint, elem) {
        if (elementsFromPoint.some(function (elementFromPoint) {
            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);
        })) {
            return true;
        }
        // shadow root
        // filter unique elements with shadowRoot
        var elemsWithShadowRoot = [].concat(elementsFromPoint);
        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {
            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;
        });
        // getOverlappingElements of every element with shadowRoot
        var shadowElementsFromPoint = [];
        for (var i = 0; i < elemsWithShadowRoot.length; ++i) {
            var shadowElement = elemsWithShadowRoot[i];
            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));
        }
        // remove duplicates and parents
        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);
        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {
            return !elementsFromPoint.includes(x);
        });
        if (shadowElementsFromPoint.length === 0) {
            return false;
        }
        var r = isOverlappingElementMatch(shadowElementsFromPoint, elem);
        return r;
    }
    // copied from `isElementInViewport.js`
    function isElementPartInViewport(elem) {
        if (!elem.getBoundingClientRect) {
            return true;
        }
        var rect = elem.getBoundingClientRect();
        var viewport = getViewport();
        var horInView = isOverlapping(rect.left, rect.left + rect.width, 0, viewport.windowWidth);
        var vertInView = isOverlapping(rect.top, rect.top + rect.height, 0, viewport.windowHeight);
        var inView = horInView && vertInView;
        return inView;
    }
    function isDisplayed(elem) {
        if (!isElementPartInViewport(elem)) {
            return false;
        }
        else {
            if (elem.disabled !== true) {
                var r = isOverlappingElementMatch(getOverlappingElements(elem), elem);
                return r;
            }
            else {
                return false;
            }
        }
    }
    if (!isElementPartInViewport(element) && !options.autoScroll) {
        return options.visibleOutsideViewport;
    }
    else if (isDisplayed(element)) {
        return true;
    }
    else if (options.autoScroll && element.scrollIntoView) {
        var prevX = window.scrollX;
        var prevY = window.scrollY;
        try {
            element.scrollIntoView(scrollIntoViewFullSupport ? {
                block: 'center',
                inline: 'center'
            } : false);
            if (!isDisplayed(element)) {
                element.scrollIntoView(scrollIntoViewFullSupport ? {
                    block: 'nearest',
                    inline: 'nearest'
                } : true);
                return isDisplayed(element);
            }
            else {
                return true;
            }
        }
        finally {
            window.scroll(prevX, prevY);
        }
    }
    else {
        return false;
    }
}
exports.isElementDisplayed = isElementDisplayed;
//# sourceMappingURL=isElementDisplayed.js.map