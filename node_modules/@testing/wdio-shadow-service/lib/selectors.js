"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.getElementsMatching = exports.filterExistingSelectors = exports.intersect = void 0;
var shadowElement_1 = require("./shadowElement");
var isElementDisplayed_1 = require("./isElementDisplayed");
var utils_1 = require("./utils");
/**
 * @hidden
 * @param a
 * @param b
 */
function intersect(a, b) {
    return (a && b) ? a.filter(function (item) { return b.indexOf(item) >= 0; }) : a;
}
exports.intersect = intersect;
/**
 * @hidden
 * @param findShadowElement
 * @param intersect
 * @param filter
 * @param SHADOW_PREFIX
 * @param IsElementDisplayed
 */
function filterExistingSelectors(findShadowElement, intersect, SHADOW_PREFIX, isElementDisplayed) {
    /**
     * First elements in first positions of each matcher represents a wrapper that should
     * contain the others for the wrapper to be present. Only those elements would be returned.
     */
    return function (root, matchers) {
        var _this = this;
        var filter = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            filter[_i - 2] = arguments[_i];
        }
        var shadowPrefix = new RegExp('^' + SHADOW_PREFIX);
        var all = null;
        if (filter) {
            if (typeof filter[0] === 'string') {
                all = Array.from(findShadowElement(root || document, filter[0].replace(shadowPrefix, ''), true, this));
            }
            else if (filter.length) {
                all = Array.from(filter);
            }
        }
        var list = [];
        var structure = matchers.map(function (matcher) {
            var wrapperSelector = matcher.wrapperSelector;
            var wrappers = wrapperSelector ?
                intersect(Array.from(findShadowElement(root || document, wrapperSelector.replace(shadowPrefix, ''), true, _this)), all) :
                [root];
            var components = [];
            wrappers.forEach(function (wrapper) {
                var selectors = matcher.additionalSelectors || [];
                var others = selectors.map(function (selector) {
                    return findShadowElement(wrapper, selector.replace(shadowPrefix, ''), false, _this);
                }).filter(function (element) { return element; });
                //If not all elements were found inside the wrapper then the component is not present
                if (others.length === selectors.length && isElementDisplayed(wrapper, matcher.options)) {
                    components.push(wrapper);
                }
            });
            var componentsIx = components.map(function (element) {
                //We map the array to the positions adding the selector at the end
                //Some browser drivers are not able to return elements in deeps structures
                //and some others see deep structures as recursive... so we keep it as plain
                //as possible...
                list.push(element);
                return list.length - 1;
            }, []);
            componentsIx.push(wrapperSelector);
            return componentsIx;
        });
        var result = list;
        result.push(structure);
        return result;
    };
}
exports.filterExistingSelectors = filterExistingSelectors;
/**
 * @hidden
 */
function getElementsMatching(container, filter, matchers) {
    if (filter === void 0) { filter = []; }
    if (matchers.reduce(function (a, i) { return a
        .concat(i.additionalSelectors || [])
        .concat(i.wrapperSelector ? [i.wrapperSelector] : []); }, [])
        .map(utils_1.parseSelector)
        .map(function (data) { return data.using; })
        .find(function (type) { return type !== utils_1.SelectorType.css && type !== utils_1.SelectorType.deep; })) {
        throw Error('Only css or deep selectors are supported right now in Acis, please change the selector to css.' + JSON.stringify(matchers));
    }
    function getElementsMatchingBuilder() {
        return utils_1.browserWrapper(filterExistingSelectors)(shadowElement_1.findShadowElement, intersect, shadowElement_1.SHADOW_PREFIX, isElementDisplayed_1.isElementDisplayed);
    }
    var frontMatchers = matchers.map(function (matcher) { return ({
        additionalSelectors: matcher.additionalSelectors,
        options: isElementDisplayed_1.getConfigFromVisibilityCheckType(matcher.visibilityCheckConfig),
        wrapperSelector: matcher.wrapperSelector
    }); });
    var browserResult = browser.execute.apply(browser, __spreadArrays([getElementsMatchingBuilder(), container || undefined, frontMatchers], (typeof filter === 'string' ? [filter] : filter.map(utils_1.cleanElement))));
    var structure = browserResult.pop();
    return structure.map(function (elements) {
        var selector = elements.pop();
        return utils_1.elementsOutputMapper(selector, elements.map(function (ix) { return browserResult[ix]; }), container);
    });
}
exports.getElementsMatching = getElementsMatching;
//# sourceMappingURL=selectors.js.map