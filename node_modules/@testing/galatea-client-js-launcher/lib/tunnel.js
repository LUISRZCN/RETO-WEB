const spawn = require('child_process').spawn;
const fs = require('fs');
const crypto = require("crypto");

const PLATFORM_MAP = {
    darwin: 'macos',
    win32: 'windows',
    linux: 'linux'
};

const ARCH_MAP = {
    x64: 'amd64',
    x32: '386'
};

const EXT_MAP = {
    win32: '.exe'
};

const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_TIMEOUT = 180000;
const DEFAULT_SPAWN_OPTIONS = {
    stdio: 'pipe',
    detached: false
}


module.exports = class TunnelRunner {

    constructor() {
        this.logfile = null;
        this.timeout = DEFAULT_TIMEOUT;
        this.tunnelId = null
        this.tunnelProcess = null;
    }

    async start(params) { 
        this.logFile = params.logFile;       
        this.timeout = params.timeout || DEFAULT_TIMEOUT;
        this.tunnelId = params.tunnelId || crypto.randomBytes(16).toString("hex")
        const binary = buildSupportedBinaryFilePath();
        const args = buildProcessArgs(params, this.tunnelId);
        try {
            await this.beginTunnellingAttempts(binary, args);
        } catch(e) {
            throw e;
        }

        return this.tunnelId;
    }
    async beginTunnellingAttempts(binary, args) {
        let attempts = 0;
        let success = false;
        do {
            console.log(`[galatea-tunnel-client] connection attempt ${++attempts}/${MAX_RETRY_ATTEMPTS}...`)
            try {
                await this.attemptCreateTunnel(binary, args);
                success = true;
            } catch(e) {
                console.warn("[galatea-tunnel-client] failed tunneling attempt")
                success = false;
            }
        } while(!success && attempts < MAX_RETRY_ATTEMPTS);
        
        if(!success) {
            throw `[galatea-tunnel-client] tunnel connection failed after ${MAX_RETRY_ATTEMPTS} attempts - exiting...`;
        }

        return success;
    }

    async attemptCreateTunnel(binary, args) {
        this.tunnelProcess = this.startTunnelProcess(binary, args);
        console.log("[galatea-tunnel-client] process started");
        return this.waitForTunnel(this.tunnelProcess);
    }


    startTunnelProcess(binary, args) {
        const tunnelProcess = spawn(binary, args, DEFAULT_SPAWN_OPTIONS);
        if (this.logFile) {
            tunnelProcess.stdout.pipe(fs.createWriteStream(this.logFile, {flags:'a'}));
            tunnelProcess.stderr.pipe(fs.createWriteStream(this.logFile, {flags:'a'}));
        }
        tunnelProcess.unref && tunnelProcess.unref();

        process.on('exit', () => {
            this.stop();
        });

        return tunnelProcess;
    }

    async waitForTunnel(tunnelProcess) {
        return new Promise((resolve, reject) => {
            const timeoutRef = setTimeout(async () => {
                await this.stop();
                reject("[galatea-tunnel-client] Error starting tunnel: Didn't see connected message. Timeout");
            }, this.timeout);
            let data = " ";
            tunnelProcess.stdout.on("data", (chunk) => {
                data = data && data + chunk;
                if(!this.logFile) {
                    console.log(chunk.toString());
                }
                if(data && data.indexOf("client: Connected") > 0)  {
                    console.log("[galatea-tunnel-client] connected. Id: " + this.tunnelId);
                    clearTimeout(timeoutRef);
                    data = undefined;
                    resolve(this.tunnelId);
                }
            });
        });
    }

    async stop() {
        console.log("[galatea-tunnel-client] process finished");
        this.tunnelProcess.kill();
    }
}

const buildSupportedBinaryFilePath = () => {
    if(!ARCH_MAP[process.arch] || !PLATFORM_MAP[process.platform]) {
        throw `[galatea-tunnel-client] ${process.platform}-${process.arch} is not a supported context for galatea-client`;
    }
    const binary = `galatea-tunnel-${PLATFORM_MAP[process.platform]}-${ARCH_MAP[process.arch]}${EXT_MAP[process.platform] || ''}`;
    return __dirname + '/../bin/' + binary;
}

const buildProcessArgs = ({
    server,
    username,
    password,
    grantedGroups,
    proxy,
    args: extra = []
}, tunnelId) => {
    if (!server) {
        throw "[galatea-tunnel-client] Tunnel server should be specified";
    }

    const args = [
        '-s', server,
        '-i', tunnelId,
        '-v',
    ];

    if (username && password) {
        args.push('--auth', `${username}:${password}`);
    }

    if (grantedGroups) {
        args.push('-g', grantedGroups);
    }

    if (proxy) {
        args.push('-p', proxy);
        console.log(`[galatea-tunnel-client] Proxy detected: ${proxy}`);
    }

    args.concat(extra);
    return args;
}