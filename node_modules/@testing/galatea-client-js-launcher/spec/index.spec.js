const mockSpawn = require("mock-spawn");
const mockery = require('mockery');
const GALATEA_TUNNEL_TEST_CONFIG = {
    galateaTunnel: true,
    galateaTunnelOpts: {
        server: "Some server",
        timeout: 500,
        tunnelId: "1234"
    }
};
const SAMPLE_CAPABILITIES = [{ tunnelId: 12345 }]
var mySpawn;
describe("Galatea tunnel client js wrapper", function () {
    let sut;
    beforeEach(function () {
        mySpawn = mockSpawn();
        mySpawn.setSignals({ SIGTERM: true, SIGINT: false });

        mockery.enable({ useCleanCache: true })
        mockery.registerMock('child_process', { spawn: mySpawn });
        mockery.registerAllowable('../lib/wdio-service-wrapper.js', true);
        const WdioServiceWrapper = require('../lib/wdio-service-wrapper.js');
        sut = new WdioServiceWrapper();
    });
    afterEach(function () {
        mockery.deregisterAll();
        mockery.resetCache();
        mockery.disable();
    }); 

    describe("when attempting to spawn child process", function () {

        it("should fail when running on unsupported platforms", async function () {
            const originalPlatform = process.platform;
            Object.defineProperty(process, 'platform', {
                value: 'microwave'
            });
            success = await testOnPrepare()
            expect(success).toBeFalsy();
            Object.defineProperty(process, 'platform', {
                value: originalPlatform
            });
    
            const originalArch = process.arch;
            Object.defineProperty(process, 'arch', {
                value: 'MIPS'
            });
            success = await testOnPrepare()
            expect(success).toBeFalsy();
            Object.defineProperty(process, 'arch', {
                value: originalArch
            });
            expect(mySpawn.calls.length).toEqual(0);
        })
    });

    describe("when trying to create a tunnel", function () {    

        it("should create a tunnel", async function () {
            mySpawn.sequence.add(function (cb) {
                this.stdout.write("client: Connected")
            });
            success = await testOnPrepare()
            expect(success).toBeTruthy();
            expect(mySpawn.calls.length).toEqual(1);
        });

        it("should retry creating a tunnel after it failed once", async function () {
            const doNothing = function () { };
            mySpawn.sequence.add(doNothing);
            mySpawn.sequence.add(function (cb) {
                this.stdout.write("client: Connected")
            });

            success = await testOnPrepare()
            expect(success).toBeTruthy();
            expect(mySpawn.calls.length).toEqual(2);
        });


        it("should stop trying to create tunnels after 3 attemps", async function () {
            const doNothing = function () { };
            mySpawn.sequence.add(doNothing);
            success = await testOnPrepare()
            expect(success).toBeFalsy();
            expect(mySpawn.calls.length).toEqual(3);
        });

        it("should stop the tunnel on complete", async function () {
            mySpawn.sequence.add(function (cb) {
                this.stdout.write("client: Connected")
            });
            success = false;
            try {
                await sut.onPrepare(GALATEA_TUNNEL_TEST_CONFIG, SAMPLE_CAPABILITIES)
                await sut.onComplete(0, GALATEA_TUNNEL_TEST_CONFIG);
                success = true;
            } catch (e) {
                console.error("Error: " + e)
                success = false;
            }

            expect(success).toBeTruthy();
            expect(mySpawn.calls.length).toEqual(1);
        })
    })

    
    

    const testOnPrepare = async (
        config = GALATEA_TUNNEL_TEST_CONFIG, 
        capabilities = SAMPLE_CAPABILITIES
    ) => {
        success = false;
        try {
            await sut.onPrepare(config, capabilities);
            success = true;
        } catch (e) {
            console.error("Error: " + e)
            success = false;
        }

        return success;
    }
})

