"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscardablePage = exports.ErrorPage = exports.PageObject = exports.Page = void 0;
/**
 * Page Objects represent a page or view in an application and they should be loaded from Step
 * Classes only via **[pageProvider](./PageProvider.md)** api.
 *
 *   ```ts
 *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `#example`
 *     })
 *     export class ExamplePage extends PageObject {
 *     }
 *   ```
 *
 * PageObjects are created through Classes that extend one of the superClasses listed below:
 *
 * -----------------------
 *
 * @module PageObjects
 */
require("@testing/wdio-shadow-service");
const container_1 = require("../containers/container");
const util_1 = require("util");
/**
 * Page Objects represent a page or view in an application and they should be loaded from Step
 * Classes only via **[pageProvider](./PageProvider.md)** api.
 *
 *   ```ts
 *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `#example`
 *     })
 *     export class ExamplePage extends PageObject {
 *     }
 *   ```
 *
 * PageObjects are created through Classes that extend one of the superClasses listed below:
 *
 * -----------------------
 *
 */
class Page extends container_1.ContainerObject {
    /**
     * @hidden
     */
    constructor() {
        super();
        this.isPage = true;
    }
    /**
     * It provides information of the page for error and debugging reporting.
     * Feel free to override this method to add or remove data.
     *
     * --
     */
    getDebugInformation() { return 'Page of type: ' + this.type; }
    /**
     *
     */
    isDisplayed() {
        return this.isCurrent();
    }
    /**
     * This method should return true when the view or page loaded in the browser matches with
     * the *PageObject* instance active or, in other words, when the view or page represented by the
     * *PageObject* is the current page.
     *
     * The check is performed by comparing the page object's metadata defined via
     * [PageContext](../modules/PageContext.md) with the view or page loaded in the
     * application against which the tests are being executed.
     *
     * If you override this class remember to call `super.isCurrent()` to keep this behavior.
     *
     * ```ts
     *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
     *
     *     @PageContext({
     *         wrapper: `#example`
     *     })
     *     export class ExamplePage extends PageObject {
     *     }
     *  ```
     *
     * --
     */
    isCurrent() {
        if (!browser.isNativeApplication() && this.context.context !== "web")
            return false;
        const currentUrl = (this.context.context === 'web') && browser.execute(function () { return document.location.href; });
        return (this.context.context !== 'web' || !this.route || !!this.route.match(currentUrl)) &&
            super.isDisplayed();
    }
    /**
     * It navigates to the page or view associated to the Page Object provided,
     * relying on the metadata passed via [PageContext](../modules/PageContext.md) decorator.
     *
     * - When no parameters are passed, it uses the value set in the **goPath** or **path**
     * property via [PageContext](PageContext.md) decorator.
     * - Don't invoke this method directly, use [pageProvider's **go**](pageProvider.md) method
     * instead.
     *
     * Important - Note that with this method, you won't be able to interact with elements
     * as you are theoretically not in the page yet. Avoid interacting with any other page
     * methods or elements.
     *
     * @hidden
     */
    go(values) {
        if (this.context.context !== 'web') {
            throw new Error(`Deep linking is only supported in web context right now.`);
        }
        if (this.goRoute === undefined) {
            throw new Error(`${this.type} doesn't define a goPath or path sting property. Set it to something like '/my/path/:param' to be able to use go, or override this method`);
        }
        if (util_1.isString(this.goRoute)) {
            browser.url(this.goRoute);
        }
        else {
            if (this.goRoute.stringify) {
                browser.url(this.goRoute.stringify(Object.assign({ _: '' }, values)));
            }
            else {
                throw new Error(`Could not navigate to page '${this.type}'. Path was specified as RegExp and no goPath was indicated.`);
            }
        }
    }
    /**
     * @hidden
     */
    getSlot() {
        return this.wrapper;
    }
}
exports.Page = Page;
/**
 * @hidden
 */
exports.PageObject = Page;
/**
 * There're times when changes in the application context have not been replicated into
 * the testing environment and, during the e2e testing process, a test fails because an
 * element selector or route is not found.
 *
 * In order to find out more quickly that a test is failing for this reason, we have at
 * our disposal *ErrorPage* Classes:
 *
 * Every time the **[pageProvider's wait](pageProvider.md#wait)** method is invoked and an
 * ErrorPage with the same page context associated to the view or page loaded in the
 * application exists, the test will fail with the details provided by the
 * [getErrorDetails](#geterrordetails) method (for instance, when we request a page that
 * doesn't exist anymore and a 404 view loads instead).
 *
 * Example of ErrorPage-type Class:
 *
 * ```ts
 *     import { ErrorPage, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `shop-404-warning`
 *     })
 *     export class Error404Page extends ErrorPage {
 *
 *         getErrorDetails() {
 *             return `
 *                 error: 404
 *                 handler: Error404Page
 *                 url:     ${browser.getUrl()}
 *                 message: ${$(`h1`).getText()}
 *             `;
 *         }
 *     }
 * ```
 *
 * -----------------------
 */
class ErrorPage extends Page {
}
exports.ErrorPage = ErrorPage;
/**
 * When navigating through an application, it can happen that there're flows where an unexpected
 * view can appear radomly in certain circumstances, overlapping the content we're actually
 * trying to test (for example, a 'Happy birthday' post-login dialog in an online banking
 * application).
 *
 * To address this problem, we have at our disposal *DiscardablePage* Classes:
 *
 * Every time the **[pageProvider's wait](pageProvider.md#wait)** method is invoked and a
 * DiscardablePage with the same page context associated to the view or page loaded in the
 * application exists, the [discard](#discard) method is executed so that the unexpected view can
 * be skipped before navigating to the actual page where our testing flow is defined.
 *
 * Example of DiscardablePage-type Class:
 *
 *   ```ts
 *       import { DiscardablePage, PageContext } from "@testing/wdio-page-objects";
 *       import { Config } from "@testing/wdio-config";
 *
 *       @PageContext({
 *           selector: `shop-app shop-cart-modal.opened`
 *       })
 *       export class ShopCartModal extends DiscardablePage {
 *
 *           discard() {
 *               const timeout = (browser.config as Config).timeouts.S;
 *               $(`${this.context.selector} #closeBtn`).click();
 *               browser.waitUntil(() => !this.isCurrent(), timeout, "dialog not hidden");
 *           }
 *       }
 *   ```
 *
 * -----------------------
*/
class DiscardablePage extends Page {
}
exports.DiscardablePage = DiscardablePage;
//# sourceMappingURL=page.js.map