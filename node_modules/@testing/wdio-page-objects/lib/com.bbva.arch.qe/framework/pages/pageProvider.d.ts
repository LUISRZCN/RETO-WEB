import { Page } from './page';
import { GenericProvider } from '../utils/provider';
/**
 * @hidden
 */
export declare type PageClass<T extends Page> = Function & {
    prototype: T;
};
declare type PageConstructor<T extends Page> = new (...args: any[]) => T;
/**
 * @hidden
 */
export declare enum PageLifeCycleEvents {
    Detected = "Detected",
    Loading = "Loading",
    Loaded = "Loaded"
}
/**
 *
 */
export declare abstract class PageProvider extends GenericProvider {
    /**
     * Wait's for any of the provided pages to be present in the browser based on the metadata passed to the
     * `PageContext` decorator, for the max amount of time obtained for their timeout getter or
     * configured in timeouts.L in your config file by default.
     *
     * While doing this, it automatically checks for `DiscardablePage` discarding them if
     * present, or `ErrorPage` failing fast in case some of them raises.
     *
     * At the end this method relies on `PageObject.isCurrent()` method. You can specialize that
     * method in your PageObject to fine tune it's behavior.
     *
     * @param types List of PageObject to get
     * @see PageContext
     * @see DiscardablePage
     * @see ErrorPage
     */
    abstract wait<T extends Page>(...types: PageClass<T>[]): T;
    /**
     * Navigates to the page provided using the `goPath` or `path` provided in the
     * `PageContext` decorator. You can provide arguments if they are declared in the form
     * `/path/to/page/:params1/:params2`:
     *
     * ```
     * pageProvider.go(MyPage, {param1: 'value1', param2: 'value2' })
     * ```
     *
     * By default this method waits using `pageProvider.wait` internally. You can override this
     * by using the `wait` parameter.
     * @param type
     * @param urlparams object containing the url params
     * @param wait
     */
    abstract go<T extends Page>(type: PageClass<T>, urlparams?: {
        [key: string]: string;
    }, wait?: boolean): T;
}
/**
 * @hidden
 */
export declare class PrivatePageProvider extends PageProvider {
    private registry;
    constructor();
    private get timeout();
    private getPageId;
    private throwErrorWithErrorPageInfo;
    private checkCandidatesWithErrorsAndDiscardables;
    private waitUntilAnyOfInstancesIsCurrent;
    wait<T extends Page>(...types: PageClass<T>[]): T;
    go<T extends Page>(type: PageClass<T>, urlparams?: {
        [key: string]: string;
    }, wait?: boolean): T;
    private getInstance;
    /**
     * Directly returns an instance of the provided `PageObject` class without any wait
     * Using this method is normally not a good idea. You can use it for example to build
     * a PageObject and check if it's not the current page.
     *
     * @param type
     * @deprecated This will not work in framed applications and with wrapper context property
     * @hidden
     */
    get<T extends Page>(type: PageClass<T>): T;
    private findMatchingPages;
    register(pageType: PageConstructor<Page>): void;
    clear(): void;
}
/**
 * @hidden
 */
export declare const pageProvider: PrivatePageProvider;
export {};
//# sourceMappingURL=pageProvider.d.ts.map