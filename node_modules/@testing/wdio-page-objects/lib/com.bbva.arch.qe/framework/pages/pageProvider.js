"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pageProvider = exports.PrivatePageProvider = exports.PageProvider = exports.PageLifeCycleEvents = void 0;
/**
 * *pageProvider* is the api that provides us with functionality to interact with
 * page objects, so from a Cucumber Step Class we can go to a view or page and/or
 * wait for it to load just by invoking the respective [PageObject](./pages_page.md).
 *
 * -----------------------
 *
 * @module PageProvider
 */
const assert_1 = require("assert");
const base_1 = require("@testing/base");
const page_1 = require("./page");
const container_1 = require("../containers/container");
const pageProxy_1 = require("./pageProxy");
const wdio_shadow_service_1 = require("@testing/wdio-shadow-service");
const async_sync_1 = require("../utils/async-sync");
const containerProxy_1 = require("../containers/containerProxy");
const provider_1 = require("../utils/provider");
const logger = base_1.getLogger('framework.pages.PageProvider');
const NS_PER_MSSEC = 1e6;
function timeDiff(time) {
    const diff = process.hrtime(time);
    return diff[0] * 1000 + diff[1] / NS_PER_MSSEC;
}
/**
 * @hidden
 */
var PageLifeCycleEvents;
(function (PageLifeCycleEvents) {
    PageLifeCycleEvents["Detected"] = "Detected";
    PageLifeCycleEvents["Loading"] = "Loading";
    PageLifeCycleEvents["Loaded"] = "Loaded";
})(PageLifeCycleEvents = exports.PageLifeCycleEvents || (exports.PageLifeCycleEvents = {}));
/**
 *
 */
class PageProvider extends provider_1.GenericProvider {
}
exports.PageProvider = PageProvider;
/**
 * @hidden
 */
class PrivatePageProvider extends PageProvider {
    constructor() {
        super();
        this.registry = global.__ACIS_PAGE_PROVIDER_REGISTRY = global.__ACIS_PAGE_PROVIDER_REGISTRY || [];
    }
    get timeout() {
        const config = browser.config;
        return (config.timeouts && config.timeouts.L) || 20000;
    }
    getPageId(p) {
        return `${p.name}#${new p().__filename}`;
    }
    throwErrorWithErrorPageInfo(error) {
        throw new Error(`Un expected error page found with type '${error.constructor.name}'
      Info: ${error.getErrorDetails()}
    `);
    }
    checkCandidatesWithErrorsAndDiscardables(expectedTypeIds, all) {
        const errors = [], discard = [], regular = [];
        this.findMatchingPages(all).forEach(page => {
            const id = this.getPageId(Object.getPrototypeOf(page).constructor);
            if (expectedTypeIds.indexOf(id) >= 0) {
                if (!container_1.isLoading(page)) {
                    regular.push(page);
                }
            }
            else if (page instanceof page_1.ErrorPage) {
                errors.push(page);
            }
            else if (page instanceof page_1.DiscardablePage) {
                discard.push(page);
            }
        });
        if (errors.length) {
            this.throwErrorWithErrorPageInfo(errors[0]);
        }
        discard.forEach(p => {
            logger.info(`Discardable found ${Object.getPrototypeOf(p).constructor.name}. Discarding`);
            p.discard();
        });
        //If we have discarded a Page then we cannot trust in regular pages found yet.
        return discard.length ? [] : regular;
    }
    waitUntilAnyOfInstancesIsCurrent(...instances) {
        if (browser.safeMode().waitForApplicationToCompleteTasks) {
            browser.waitForApplicationToCompleteTasks();
        }
        const timeout = instances.reduce((acc, i) => Math.max(acc, i.timeout), this.timeout);
        const types = instances.map(i => Object.getPrototypeOf(i).constructor);
        const typeIds = types.map(this.getPageId);
        const candidates = this.registry
            .filter(c => typeIds.indexOf(this.getPageId(c)) < 0)
            .map(c => new c())
            .filter(p => p instanceof page_1.DiscardablePage || p instanceof page_1.ErrorPage)
            .concat(instances);
        let found;
        const time = process.hrtime();
        do {
            found = this.checkCandidatesWithErrorsAndDiscardables(typeIds, candidates);
            if (!found.length) {
                if (timeDiff(time) > timeout) {
                    throw new assert_1.AssertionError({
                        message: `Page of type "${types.map(t => t.name) ||
                            'any'}" could not be found after ${timeDiff(time)}ms.`
                    });
                }
                if (browser.safeMode().waitForApplicationToCompleteTasks) {
                    browser.waitForApplicationToCompleteTasks();
                }
                else {
                    browser.call(() => new Promise(res => setTimeout(res, 200)));
                }
            }
        } while (!found.length);
        if (found.length > 1) {
            logger.warn(`Multiple pages matching wait request '[${found.map(Object.getPrototypeOf).join(',')}]'. Please redesign your selectors to avoid page ambiguity.`);
        }
        if (browser.safeMode().waitForApplicationToCompleteTasks) {
            browser.waitForApplicationToCompleteTasks();
        }
        return found[0];
    }
    wait(...types) {
        return base_1.patchedContextHelper.runPatched(() => {
            let toSearch;
            if (!types.length) {
                toSearch = this.registry
                    .filter(c => {
                    const inst = new c();
                    return !(inst instanceof page_1.DiscardablePage || inst instanceof page_1.ErrorPage);
                });
            }
            else {
                toSearch = this.registry
                    .filter(c => types.some(t => {
                    let parent = c;
                    while (parent) {
                        if (parent === t) {
                            return true;
                        }
                        parent = Object.getPrototypeOf(parent);
                    }
                }));
            }
            if (!toSearch.length) {
                const names = this.registry.map(c => c.name);
                logger.debug("Registered pages: " + names);
                throw new Error("No registered types found in Acis for pages '" + types.map(t => t.name) + "'. You might have issues loading the pages, missing imports or loops in your sources imports. Please check.");
            }
            return this.waitUntilAnyOfInstancesIsCurrent(...toSearch.map(t => new t()));
        });
    }
    go(type, urlparams, wait = true) {
        return base_1.patchedContextHelper.runPatched(() => {
            const temp = this.getInstance(type);
            temp.go(urlparams);
            if (browser.safeMode().waitForApplicationToCompleteTasks) {
                browser.waitForApplicationToCompleteTasks();
            }
            const page = pageProxy_1.proxifyPage(temp, []);
            if (wait) {
                this.waitUntilAnyOfInstancesIsCurrent(page);
            }
            return page;
        });
    }
    getInstance(type) {
        return this.registry
            .filter(c => c.prototype instanceof type || c === type)
            .map(c => new c())
            .sort((a, b) => a.context.context.localeCompare(b.context.context))
            .find(i => i.context.context === "web" ||
            (browser.isAndroid && i.context.context === "mobile-android") ||
            (browser.isIOS && i.context.context === "mobile-ios"));
    }
    /**
     * Directly returns an instance of the provided `PageObject` class without any wait
     * Using this method is normally not a good idea. You can use it for example to build
     * a PageObject and check if it's not the current page.
     *
     * @param type
     * @deprecated This will not work in framed applications and with wrapper context property
     * @hidden
     */
    get(type) {
        const instance = this.getInstance(type);
        return pageProxy_1.proxifyPage(instance, []);
    }
    findMatchingPages(pages) {
        function filterPagesInParallel(candidates) {
            if (!candidates || !candidates.length) {
                return [];
            }
            container_1.ensureContext(candidates[0]);
            return containerProxy_1.runInFrame(candidates[0], () => async_sync_1.parallel(...candidates.map(page => () => page.isCurrent() && page)).filter(page => page));
        }
        let webCandidates = pages.filter(instance => instance.context.context === "web");
        let nativeCandidates = pages
            .filter(instance => (browser.isIOS && instance.context.context === "mobile-ios")
            || (browser.isAndroid && instance.context.context === "mobile-android"));
        if (webCandidates.length > 0) {
            container_1.ensureContext(webCandidates[0]);
            const allSelectors = webCandidates.map(candidate => ({
                additionalSelectors: typeof candidate.context.selector === "string" ? [candidate.context.selector] : candidate.context.selector,
                wrapperSelector: candidate.context.wrapper,
                visibilityCheckConfig: candidate.context.visibilityCheckConfig
            }));
            const allUrls = webCandidates
                .reduce((accum, next) => [...accum, next.route.regex.source], [])
                .filter((item, ix, me) => me.indexOf(item) === ix);
            const foundSelectors = wdio_shadow_service_1.checkIntoPage(allUrls, allSelectors);
            webCandidates = webCandidates.map((page, ix) => {
                const forUrl = foundSelectors.selectors[page.route.regex.source];
                if (forUrl && forUrl.indexOf(ix) >= 0) {
                    const frame = foundSelectors.frames[`${ix}`];
                    return frame && pageProxy_1.proxifyPage(page, frame);
                }
            }).filter(page => page);
        }
        webCandidates.forEach(item => this.events.emit(PageLifeCycleEvents.Detected, item));
        webCandidates.forEach(item => this.events.emit(PageLifeCycleEvents.Loading, item));
        //Organize them by framepath to enable parallelism (browser can only be in one frame at a time)
        const frameClusters = webCandidates.map(candidate => candidate).reduce((acc, candidate) => {
            const path = JSON.stringify(candidate.__framePath ? candidate.__framePath : '');
            acc[path] = acc[path] || [];
            acc[path].push(candidate);
            return acc;
        }, {});
        const visiblePages = Object.values(frameClusters).reduce((acc, pages) => acc.concat(filterPagesInParallel(pages)), [])
            .concat(filterPagesInParallel(nativeCandidates));
        visiblePages.forEach(item => this.events.emit(PageLifeCycleEvents.Loaded, item));
        return visiblePages;
    }
    register(pageType) {
        if (!this.registry.map(this.getPageId).filter(id => id === this.getPageId(pageType)).length) {
            logger.debug('register', this.getPageId(pageType));
            this.registry.push(pageType);
        }
    }
    clear() {
        this.registry = [];
    }
}
exports.PrivatePageProvider = PrivatePageProvider;
/**
 * @hidden
 */
exports.pageProvider = new PrivatePageProvider();
//# sourceMappingURL=pageProvider.js.map