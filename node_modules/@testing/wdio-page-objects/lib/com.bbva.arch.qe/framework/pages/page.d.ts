/**
 * Page Objects represent a page or view in an application and they should be loaded from Step
 * Classes only via **[pageProvider](./PageProvider.md)** api.
 *
 *   ```ts
 *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `#example`
 *     })
 *     export class ExamplePage extends PageObject {
 *     }
 *   ```
 *
 * PageObjects are created through Classes that extend one of the superClasses listed below:
 *
 * -----------------------
 *
 * @module PageObjects
 */
import '@testing/wdio-shadow-service';
import * as UrlPattern from 'url-pattern';
import { ContainerObject } from "../containers/container";
import { ContainerContextMetadata } from "../containers/containerContext";
/**
 * @hidden
 */
export interface InternalPageContext {
    /**
     * Use this to provide a matcher for the url of the page. Protocol, host and port
     * will be stripped out prior to matching, but you will need to provide the rest of
     * the url.
     *
     * This url will be used both for matching during `pageProvider.wait` and for navigating
     * in `pageProvider.go` calls unless it's overridden by `goPath`.
     *
     * You can match dynamic elements of the url by preceding the entry by `:` as in the following
     * example: `/accounts/:number/movement/:id`
     *
     * You may also provide a RegExp for more powerful matching but you will have to provide
     * a goPath in order to be able to call `pageProvider.go` on the decorated `PageObject`.
     *
     * Check [url-pattern](https://github.com/snd/url-pattern) for details on the syntax
     */
    path?: string | RegExp;
    /**
     * If this is set, it will be used for `pageProvider.go` navigation instead of `path`. Check
     * the `path` property for more details on the syntax.
     */
    goPath?: string;
}
/**
 * @hidden
 */
export declare type PageContextMetadata = InternalPageContext & ContainerContextMetadata;
/**
 * Page Objects represent a page or view in an application and they should be loaded from Step
 * Classes only via **[pageProvider](./PageProvider.md)** api.
 *
 *   ```ts
 *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `#example`
 *     })
 *     export class ExamplePage extends PageObject {
 *     }
 *   ```
 *
 * PageObjects are created through Classes that extend one of the superClasses listed below:
 *
 * -----------------------
 *
 */
export declare abstract class Page extends ContainerObject {
    /**
     * Access to the context metadata provider via [PageContext](../modules/PageContext.md)
     * decorator.
     *
     * --
     */
    readonly context: Readonly<PageContextMetadata>;
    /**
     * @hidden
     */
    readonly route: Readonly<UrlPattern>;
    /**
     * @hidden
     */
    readonly goRoute: Readonly<UrlPattern | string>;
    /**
     * @hidden
     */
    constructor();
    /**
     * It provides information of the page for error and debugging reporting.
     * Feel free to override this method to add or remove data.
     *
     * --
     */
    getDebugInformation(): string;
    /**
     *
     */
    isDisplayed(): boolean;
    /**
     * This method should return true when the view or page loaded in the browser matches with
     * the *PageObject* instance active or, in other words, when the view or page represented by the
     * *PageObject* is the current page.
     *
     * The check is performed by comparing the page object's metadata defined via
     * [PageContext](../modules/PageContext.md) with the view or page loaded in the
     * application against which the tests are being executed.
     *
     * If you override this class remember to call `super.isCurrent()` to keep this behavior.
     *
     * ```ts
     *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
     *
     *     @PageContext({
     *         wrapper: `#example`
     *     })
     *     export class ExamplePage extends PageObject {
     *     }
     *  ```
     *
     * --
     */
    isCurrent(): boolean;
    /**
     * It navigates to the page or view associated to the Page Object provided,
     * relying on the metadata passed via [PageContext](../modules/PageContext.md) decorator.
     *
     * - When no parameters are passed, it uses the value set in the **goPath** or **path**
     * property via [PageContext](PageContext.md) decorator.
     * - Don't invoke this method directly, use [pageProvider's **go**](pageProvider.md) method
     * instead.
     *
     * Important - Note that with this method, you won't be able to interact with elements
     * as you are theoretically not in the page yet. Avoid interacting with any other page
     * methods or elements.
     *
     * @hidden
     */
    go(values?: {
        [key: string]: string;
    }): void;
    /**
     * @hidden
     */
    getSlot(): Readonly<import("@wdio/sync").Element>;
}
/**
 * @hidden
 */
export declare const PageObject: typeof Page;
/**
 * There're times when changes in the application context have not been replicated into
 * the testing environment and, during the e2e testing process, a test fails because an
 * element selector or route is not found.
 *
 * In order to find out more quickly that a test is failing for this reason, we have at
 * our disposal *ErrorPage* Classes:
 *
 * Every time the **[pageProvider's wait](pageProvider.md#wait)** method is invoked and an
 * ErrorPage with the same page context associated to the view or page loaded in the
 * application exists, the test will fail with the details provided by the
 * [getErrorDetails](#geterrordetails) method (for instance, when we request a page that
 * doesn't exist anymore and a 404 view loads instead).
 *
 * Example of ErrorPage-type Class:
 *
 * ```ts
 *     import { ErrorPage, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `shop-404-warning`
 *     })
 *     export class Error404Page extends ErrorPage {
 *
 *         getErrorDetails() {
 *             return `
 *                 error: 404
 *                 handler: Error404Page
 *                 url:     ${browser.getUrl()}
 *                 message: ${$(`h1`).getText()}
 *             `;
 *         }
 *     }
 * ```
 *
 * -----------------------
 */
export declare abstract class ErrorPage extends Page {
    /**
     * Error details to be displayed when the corresponding error view is found.
     */
    abstract getErrorDetails(): string;
}
/**
 * When navigating through an application, it can happen that there're flows where an unexpected
 * view can appear radomly in certain circumstances, overlapping the content we're actually
 * trying to test (for example, a 'Happy birthday' post-login dialog in an online banking
 * application).
 *
 * To address this problem, we have at our disposal *DiscardablePage* Classes:
 *
 * Every time the **[pageProvider's wait](pageProvider.md#wait)** method is invoked and a
 * DiscardablePage with the same page context associated to the view or page loaded in the
 * application exists, the [discard](#discard) method is executed so that the unexpected view can
 * be skipped before navigating to the actual page where our testing flow is defined.
 *
 * Example of DiscardablePage-type Class:
 *
 *   ```ts
 *       import { DiscardablePage, PageContext } from "@testing/wdio-page-objects";
 *       import { Config } from "@testing/wdio-config";
 *
 *       @PageContext({
 *           selector: `shop-app shop-cart-modal.opened`
 *       })
 *       export class ShopCartModal extends DiscardablePage {
 *
 *           discard() {
 *               const timeout = (browser.config as Config).timeouts.S;
 *               $(`${this.context.selector} #closeBtn`).click();
 *               browser.waitUntil(() => !this.isCurrent(), timeout, "dialog not hidden");
 *           }
 *       }
 *   ```
 *
 * -----------------------
*/
export declare abstract class DiscardablePage extends Page {
    /**
     * It exits from a view which may radomly appear, overlapping the flow we're actually
     * trying to test.
     */
    abstract discard(): any;
}
//# sourceMappingURL=page.d.ts.map