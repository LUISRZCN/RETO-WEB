"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PageContext = void 0;
/**
 * Page registry based in decorators which allows us to easily link a Page Object with
 * its corresponding page or view in the application's flow to be tested.
 *
 * -----------------------
 *
 * @module PageContext
 */
require("@testing/wdio-shadow-service");
const UrlPattern = require("url-pattern");
const pageProvider_1 = require("./pageProvider");
const containerContext_1 = require("../containers/containerContext");
const page_1 = require("./page");
const isElementDisplayed_1 = require("@testing/wdio-shadow-service/lib/isElementDisplayed");
/**
 * Decorator to be used with [PageObjects](PageObject.md) so metadata about
 * the page context can be provided. Check the PageContextMetadata properties for details.
 *
 * Example:
 *
 * ```typescript
 *   @PageContext({
 *    path: '/',
 *    selector: `/deep/ shop-app[page=home]`,
 *   })
 *   export class WelcomePage extends PageObject {}
 * ```
 *
 * @param ctx
 */
function PageContext(ctx) {
    const parent = containerContext_1.InternalComponentContext(ctx, false);
    return (target) => {
        const goPath = ctx.goPath !== undefined ? ctx.goPath : (!(ctx.path instanceof RegExp) && ctx.path);
        let path = ctx.path;
        if (typeof path === 'string' && path.length > 0 && path[0] != '*') {
            path = '*' + path;
        }
        if (!ctx.visibilityCheckConfig) {
            ctx.visibilityCheckConfig =
                !(target.prototype instanceof page_1.DiscardablePage || target.prototype instanceof page_1.ErrorPage) ?
                    isElementDisplayed_1.VisibilityCheckType.NotCovered :
                    isElementDisplayed_1.VisibilityCheckType.NotCoveredAndInsideViewport;
        }
        const prev = parent(target);
        try {
            const goRouteValue = goPath ? new UrlPattern(goPath) : goPath;
            const routeValue = path ? (path instanceof RegExp ?
                new UrlPattern(path) :
                new UrlPattern('(:protocol\\://)(:domain)(\\::port)' + path, { segmentValueCharset: 'a-zA-Z0-9-_~%.+' })) : new UrlPattern(/.*/);
            const value = {
                [target.name]: class extends prev {
                    constructor() {
                        super(...arguments);
                        this.goRoute = goRouteValue;
                        this.route = routeValue;
                    }
                }
            }[target.name];
            pageProvider_1.pageProvider.register(value);
            return value;
        }
        catch (e) {
            if (e.message === "could only partially parse pattern") {
                throw new Error(`Could not parse patterns for paths provided in '${JSON.stringify(ctx)}'. Please don't include domains, protocol or ports in paths.`);
            }
            else {
                throw e;
            }
        }
    };
}
exports.PageContext = PageContext;
//# sourceMappingURL=pageContext.js.map