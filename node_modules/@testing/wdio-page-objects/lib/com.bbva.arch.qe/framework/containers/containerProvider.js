"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.containerProvider = exports.ContainerProvider = exports.ComponentLifeCycleEvents = void 0;
/**
 * *containerProvider* is the api that provides us with functionality to interact with
 * html elements represented by their respective [ContainerObject](./containers_container.md).
 *
 * -----------------------
 *
 * @module componentProvider
 */
require("@testing/wdio-shadow-service");
const assert_1 = require("assert");
const base_1 = require("@testing/base");
const container_1 = require("./container");
const component_1 = require("../components/component");
const containerProxy_1 = require("./containerProxy");
const wdio_shadow_service_1 = require("@testing/wdio-shadow-service");
const async_sync_1 = require("../utils/async-sync");
const provider_1 = require("../utils/provider");
const logger = base_1.getLogger('framework.pages.ContainerProvider');
const NS_PER_MSSEC = 1e6;
function timeDiff(time) {
    const diff = process.hrtime(time);
    return diff[0] * 1000 + diff[1] / NS_PER_MSSEC;
}
/**
 * @hidden
 */
var ComponentLifeCycleEvents;
(function (ComponentLifeCycleEvents) {
    ComponentLifeCycleEvents["Detected"] = "Detected";
    ComponentLifeCycleEvents["Loading"] = "Loading";
    ComponentLifeCycleEvents["Loaded"] = "Loaded";
})(ComponentLifeCycleEvents = exports.ComponentLifeCycleEvents || (exports.ComponentLifeCycleEvents = {}));
/**
 * - This class exposes methods to work with ContainerObjects, DOM elements that are not encapsulated as web components.
 * - ContainerObjects are decorated with `ContainerContext` and represent the base Class for page objects.
 * - ContainerObjects must be declared in an `src\/**\/*container.ts` file.
 *
 * -----------------------
 */
class ContainerProvider extends provider_1.GenericProvider {
}
exports.ContainerProvider = ContainerProvider;
class PrivateContainerProvider extends ContainerProvider {
    constructor() {
        super();
        this.registry = [];
        this.registry = global.__ACIS_COMPONENT_PROVIDER_REGISTRY = global.__ACIS_COMPONENT_PROVIDER_REGISTRY || [];
    }
    cast(elements, ...types) {
        const one = !Array.isArray(elements);
        const aElements = (one ? [elements] : elements);
        const found = this.waitForContainers(undefined, aElements, ...types);
        return one ? found.pop() : found;
    }
    find(...params) {
        return this.findMany(...params).pop();
    }
    findMany(...params) {
        const parent = (params[0].$ || isContainerObject(params[0])) ? params.shift() : undefined;
        const selector = parent && typeof params[0] === 'string' ? params.shift() : undefined;
        return this.waitForContainers(parent, selector, ...params);
    }
    get timeout() {
        const config = browser.config;
        return (config.timeouts && config.timeouts.L) || 20000;
    }
    getContainerId(p) {
        return `${p.name}#${new p().__filename}`;
    }
    checkCandidates(selector, container, all) {
        const find = () => {
            const items = this.findMatchingContainers(selector, container, all);
            //If any of them is loading... wait for it to load
            logger.debug('Components found in page ', items);
            items.forEach(item => this.events.emit(ComponentLifeCycleEvents.Detected, item));
            items.forEach(item => this.events.emit(ComponentLifeCycleEvents.Loading, item));
            const loading = items.find(container_1.isLoading);
            if (loading) {
                logger.debug('Component is still loading', loading);
                return [];
            }
            else {
                logger.debug('Components ended loading', items);
                items.forEach(item => this.events.emit(ComponentLifeCycleEvents.Loaded, item));
                return items;
            }
        };
        return isContainerObject(container) ? containerProxy_1.runInFrame(container, find) : find();
    }
    anyOfInstancesIsCurrent(selector, container, ...instances) {
        return this.checkCandidates(selector, container, instances);
    }
    waitUntilAnyOfInstancesIsCurrent(selector, container, ...instances) {
        const timeout = instances.reduce((acc, i) => Math.max(acc, i.timeout), this.timeout);
        let found;
        const time = process.hrtime();
        do {
            found = this.anyOfInstancesIsCurrent(selector, container, ...instances);
            if (!found.length) {
                if (timeDiff(time) > timeout) {
                    const types = instances.map(i => Object.getPrototypeOf(i).constructor);
                    throw new assert_1.AssertionError({
                        message: `Component of type "${types.map(t => t.name) ||
                            'any'}" could not be found after ${timeDiff(time)}ms.`
                    });
                }
                async_sync_1.doAsync(() => new Promise(res => setTimeout(res, 200)));
            }
        } while (!found.length);
        return found;
    }
    waitForContainers(container, selector, ...types) {
        return base_1.patchedContextHelper.runPatched(() => {
            let toSearch;
            if (!types.length) {
                toSearch = this.registry;
            }
            else {
                toSearch = this.registry
                    .filter(c => types
                    .some(t => c.prototype instanceof t || c === t || this.getContainerId(t) === this.getContainerId(c)));
            }
            if (!toSearch.length) {
                throw new Error("No registered types found in Acis for components '" + types.map(t => t.name) + "'. You might have issues loading the components, missing imports or loops in your sources imports. Please check.");
            }
            const search = () => {
                if (browser.safeMode().waitForApplicationToCompleteTasks) {
                    browser.waitForApplicationToCompleteTasks();
                }
                const value = this.waitUntilAnyOfInstancesIsCurrent(selector, container, ...toSearch.map(t => new t()));
                if (browser.safeMode().waitForApplicationToCompleteTasks) {
                    browser.waitForApplicationToCompleteTasks();
                }
                return value;
            };
            if (isContainerObject(container)) {
                return containerProxy_1.runInFrame(container, search);
            }
            else {
                return search();
            }
        });
    }
    findMatchingContainers(filter, container, containers) {
        const parent = (container && getElementFromContainer(container)) || containerProxy_1.getCurrentContainer();
        if (parent) {
            parent.waitForDisplayed();
        }
        let framePath = browser.getCurrentFrame();
        if (isContainerObject(container)) {
            framePath = container.__framePath || framePath;
        }
        let webCandidates = containers.filter(instance => instance.context.context === "web");
        if (webCandidates.length > 0) {
            container_1.ensureContext(webCandidates[0]);
        }
        const webSelectors = webCandidates.map((container) => ({
            additionalSelectors: typeof container.context.selector === "string" ? [container.context.selector] : container.context.selector,
            wrapperSelector: container.context.wrapper,
            visibilityCheckConfig: container.context.visibilityCheckConfig
        }));
        const matchingElements = wdio_shadow_service_1.getElementsMatching(parent, filter, webSelectors);
        const containerObjects = webCandidates
            .map((containerClass, i) => matchingElements[i]
            .map(element => containerProxy_1.proxifyContainerObject(containerClass, element, framePath)))
            .reduce((acc, containers) => acc.concat(containers), []);
        return async_sync_1.parallel(...containerObjects.map((co => () => co.isDisplayed() && co)))
            .filter(co => co);
    }
    register(pageType) {
        if (!this.registry.map(this.getContainerId).filter(id => id === this.getContainerId(pageType)).length) {
            logger.debug('register', this.getContainerId(pageType));
            this.registry.push(pageType);
        }
    }
}
function getElementFromContainer(container) {
    if (typeof container === 'string') {
        return $(container);
    }
    else if (isContainerObject(container)) {
        const containerElement = container.getSlot();
        if (!containerElement) {
            throw new Error(`ContainerElement ${Object.getPrototypeOf(container).constructor.name} does not expose an Element through it's 'getSlot' element, so introspection is not allowed.`);
        }
        return containerElement;
    }
    else {
        return container;
    }
}
function isContainerObject(container) {
    return container instanceof container_1.ContainerObject || container instanceof component_1.ComponentObject;
}
/**
 * @hidden
 */
exports.containerProvider = new PrivateContainerProvider();
//# sourceMappingURL=containerProvider.js.map