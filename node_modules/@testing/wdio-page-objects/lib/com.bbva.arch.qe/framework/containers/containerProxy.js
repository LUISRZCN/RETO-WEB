"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxifyContainerObject = exports.ContainerProxyHandler = exports.runInContext = exports.runInFrame = exports.getCurrentContainer = void 0;
const container_1 = require("./container");
const proxy_1 = require("../utils/proxy");
const Fiber = require("fibers");
const lodash_1 = require("lodash");
const base_1 = require("@testing/base");
const $ = function (...args) {
    const $ = (Fiber.current.$ || browser.$);
    const target = getCurrentContainer() || browser;
    return $.apply(target, args);
};
const $$ = function (...args) {
    const $$ = (Fiber.current.$$ || browser.$$);
    const target = getCurrentContainer() || browser;
    return $$.apply(target, args);
};
/**
 * @hidden
 */
function getCurrentContainer() {
    return Fiber.current.$currentWrappedObject;
}
exports.getCurrentContainer = getCurrentContainer;
/**
 * @hidden
 */
function runInFrame(container, f) {
    const source = browser.getCurrentFrame();
    const framePath = container.__framePath;
    if (framePath && !lodash_1.isEqual(source, framePath)) {
        browser.switchToFrame(framePath);
        let result;
        try {
            result = f();
        }
        catch (error) {
            browser.switchToFrame(source);
            throw error;
        }
        browser.switchToFrame(source);
        return result;
    }
    else {
        return f();
    }
}
exports.runInFrame = runInFrame;
/**
 * @hidden
 */
function runWrapped(wrapper, f) {
    if (!wrapper) {
        return f();
    }
    global.$ = $;
    global.$$ = $$;
    const prev$ = Fiber.current.$;
    const prev$$ = Fiber.current.$$;
    const prevWrapper = Fiber.current.$currentWrappedObject;
    const reset = () => {
        Fiber.current.$ = prev$;
        Fiber.current.$$ = prev$$;
        Fiber.current.$currentWrappedObject = prevWrapper;
    };
    Fiber.current.$ = wrapper.$.bind(wrapper);
    Fiber.current.$$ = wrapper.$$.bind(wrapper);
    Fiber.current.$currentWrappedObject = wrapper;
    let result;
    try {
        result = f();
    }
    catch (e) {
        reset();
        throw e;
    }
    reset();
    return result;
}
/**
 * @hidden
 */
function runInContext(container, targetMethod) {
    return base_1.patchedContextHelper.runPatched(() => {
        container_1.ensureContext(container.context.context);
        return runInFrame(container, () => {
            if (!container.wrapper && container.context.wrapper) {
                container.wrapper = container.isPage ?
                    browser.$(container.context.wrapper) :
                    $(container.context.wrapper);
            }
            return runWrapped(container.wrapper || (container.context.wrapper && $(container.context.wrapper)), targetMethod.bind(container));
        });
    });
}
exports.runInContext = runInContext;
/**
 * @hidden
 */
class ContainerProxyHandler extends proxy_1.AbstractProxy {
    constructor(container) {
        super();
        this.container = container;
    }
    rewrite(targetMethod) {
        const container = this.container;
        return function (...args) {
            return runInContext(container, targetMethod.bind(this, ...args));
        };
    }
}
exports.ContainerProxyHandler = ContainerProxyHandler;
/** If element is undefined it will look for it dynamically when wrapped
 * @hidden
 */
function proxifyContainerObject(target, element, framePath) {
    const clone = new (Object.getPrototypeOf(target)).constructor();
    clone.__framePath = framePath || browser.getCurrentFrame();
    clone.wrapper = element;
    return new Proxy(clone, new ContainerProxyHandler(clone));
}
exports.proxifyContainerObject = proxifyContainerObject;
//# sourceMappingURL=containerProxy.js.map