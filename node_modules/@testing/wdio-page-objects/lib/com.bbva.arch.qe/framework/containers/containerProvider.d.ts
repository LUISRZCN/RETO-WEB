/// <reference types="@wdio/sync/webdriverio-core" />
/**
 * *containerProvider* is the api that provides us with functionality to interact with
 * html elements represented by their respective [ContainerObject](./containers_container.md).
 *
 * -----------------------
 *
 * @module componentProvider
 */
import '@testing/wdio-shadow-service';
import { ContainerObject, GenericSlottedContainerObject } from './container';
import { GenericProvider } from '../utils/provider';
/**
 * @hidden
 */
export declare type ContainerClass<T extends ContainerObject> = Function & {
    prototype: T;
};
/**
 * @hidden
 */
export declare type ContainerReference = WebdriverIO.Element | (GenericSlottedContainerObject & ContainerObject);
/**
 * @hidden
 */
export declare type ContainerConstructor<T extends ContainerObject> = new (...args: any[]) => T;
/**
 * @hidden
 */
export declare enum ComponentLifeCycleEvents {
    Detected = "Detected",
    Loading = "Loading",
    Loaded = "Loaded"
}
/**
 * - This class exposes methods to work with ContainerObjects, DOM elements that are not encapsulated as web components.
 * - ContainerObjects are decorated with `ContainerContext` and represent the base Class for page objects.
 * - ContainerObjects must be declared in an `src\/**\/*container.ts` file.
 *
 * -----------------------
 */
export declare abstract class ContainerProvider extends GenericProvider {
    /**
     * It tries to return the Object belonging to the element reference provided.
     *
     * - Use this method if you're sure you know the exact elements the components are sitting on.
     * - The containerProvider will try to match each element with the types provided and will return
     * them in the order provided by the elements Array.
     * - Note that if any of the elements did not match a component, the containerProvider will not
     * fail but just return the components found. It will also return early, meaning that it will
     * only wait for at least one component to be present in the page. If you want to wait for all
     * of the types, consider using `parallel` with several invocations to `pageProvider.cast`.
     *
     * Example:
     *
     *   ```typescript
     *       import { PageObject, PageContext, containerProvider, parallel } from "@testing/wdio-page-objects"
     *       import { CategoryContainer } from "./category.component";
     *       import { GenericSlottedContainerObject } from "@testing/wdio-page-objects/lib/com.bbva.arch.qe/framework/containers/container";
     *
     *       @PageContext({
     *           wrapper: "#example"
     *       })
     *       export class ComponentContentPage extends PageObject {
     *           getMessagesCategory(category: string): string[] {
     *               const categoryContainer = containerProvider
     *                    .cast($('#' + category), CategoryContainer);
     *
     *               return parallel(...containerProvider
     *                   .findMany(categoryContainer)
     *                   .map(c => () => c.getMessage()));
     *           }
     *       }
     *   ```
     *
     * @param element A WebdriverIO element
     * @param type ContainerObject to get
     *
     */
    abstract cast<T extends ContainerObject>(element: WebdriverIO.Element, type: ContainerClass<T>): T;
    /**
     * It tries to return a list of ComponentObjects from the element references passed.
     *
     * - Use this method if you're sure you know the exact elements the components are sitting on.
     * - The containerProvider will try to match each element with the types provided and will return
     * them in the order provided by the elements Array.
     * - Note that if any of the elements did not match a component, the containerProvider will not
     * fail but just return the components found. It will also return early, meaning that it will
     * only wait for at least one component to be present in the page. If you want to wait for all
     * of the types, consider using `parallel` with several invocations to `pageProvider.cast`.
     *
     * @param elements List of WebdriverIO elements
     * @param types List of ContainerObject to get
     *
     */
    abstract cast<T extends ContainerObject>(elements: WebdriverIO.Element[] | WebdriverIO.ElementArray, ...types: ContainerClass<T>[]): T[];
    /**
     * It looks for a single component of the provided type in the current context.
     *
     * Example:
     *
     *   ```typescript
     *        import { PageObject, PageContext } from '@testing/wdio-page-objects';
     *        import { containerProvider } from "@testing/wdio-page-objects";
     *        import { AppComponent } from "src/app/app.component";
     *        import { DataModel } from 'src/common/model/data-model';
     *
     *        @PageContext({
     *          path: '#!/dashboard',
     *          wrapper: 'cells-template-core[state="active"]',
     *        })
     *        export class DashboardPage extends PageObject {
     *
     *            viewTooltip(): void {
     *              containerProvider.find(AppComponent).viewTooltip();
     *            }
     *
     *            getTooltipServices(): DataModel {
     *              return containerProvider.find(AppComponent).getTooltipServices();
     *            }
     *        }
     *    ```
     *
     * @param type The type to receive
     */
    abstract find<T extends ContainerObject>(type: ContainerClass<T>): T;
    /**
     * It looks for a single component of the provided type inside the provided parent element.
     *
     * @param parent a parent element or ComponentObject
     * @param type The type to receive
     */
    abstract find<T extends ContainerObject>(parent: ContainerReference, type: ContainerClass<T>): T;
    /**
     * It looks for a single component of the provided type inside the provided parent element
     * and matching the given selector.
     *
     * @param parent a parent element or ComponentObject
     * @param selector a selector that should be matched by Component tags
     * @param type The type to receive
     */
    abstract find<T extends ContainerObject>(parent: ContainerReference, selector: string, type: ContainerClass<T>): T;
    /**
     * It looks for several components of the provided types.
     *
     * - It will return early, meaning that it will only wait for at least one component to be
     * present in the page. If you want to wait for all of the types, consider using `parallel`
     * with several invocations to `pageProvider.waitMany`.
     *
     * Example:
     *
     *   ```ts
     *        import { containerProvider, ComponentObject, parallel } from "@testing/wdio-page-objects"
     *        import { MessageContainer } from "./message.component";
     *
     *        export class AbstractContainer extends ComponentObject {
     *
     *            getMessage(): string {
     *                return parallel(...containerProvider
     *                    .findMany(MessageContainer)
     *                    .map(c => () => c.message))
     *                    .join(',');
     *            }
     *        }
     *    ```
     *
     * @param type The types to receive
     */
    abstract findMany<T extends ContainerObject>(...types: ContainerClass<T>[]): T[];
    /**
     * It tries to retrieve more than one component of the provided type inside the provided
     * parent element.
     *
     * - It will return early, meaning that it will only wait for at least one component to be
     * present in the page. If you want to wait for all of the types, consider using `parallel`
     * with several invocations to `pageProvider.waitMany`.
  
     * @param parent The parent element or component
     * @param type The types to receive
     */
    abstract findMany<T extends ContainerObject>(parent: ContainerReference, ...types: ContainerClass<T>[]): T[];
    /**
     * It tries to retrieve more than one component of the provided type inside the provided
     * parent element.
     *
     * - It will return early, meaning that it will only wait for at least one component to be
     * present in the page. If you want to wait for all of the types, consider using `parallel`
     * with several invocations to `pageProvider.waitMany`.
     *
     * @param parent The parent element or component
     * @param selector a selector to match by the component elements
     * @param type The types to receive
     */
    abstract findMany<T extends ContainerObject>(parent: ContainerReference, selector: string, ...types: ContainerClass<T>[]): T[];
}
declare class PrivateContainerProvider extends ContainerProvider {
    cast<T extends ContainerObject>(elements: WebdriverIO.Element | WebdriverIO.Element[], ...types: ContainerClass<T>[]): T | T[];
    find<T extends ContainerObject>(...params: any[]): T;
    findMany<T extends ContainerObject>(...params: any[]): T[];
    private registry;
    constructor();
    private get timeout();
    private getContainerId;
    private checkCandidates;
    private anyOfInstancesIsCurrent;
    private waitUntilAnyOfInstancesIsCurrent;
    private waitForContainers;
    private findMatchingContainers;
    register(pageType: ContainerConstructor<ContainerObject>): void;
}
/**
 * @hidden
 */
export declare const containerProvider: PrivateContainerProvider;
export {};
//# sourceMappingURL=containerProvider.d.ts.map