"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureContext = exports.isLoading = exports.ContainerObject = void 0;
/**
 * Page Objects represent a page or view in an application and they should be loaded from Step
 * Classes only via **[pageProvider](./PageProvider.md)** api.
 *
 *   ```ts
 *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
 *
 *     @PageContext({
 *         wrapper: `#example`
 *     })
 *     export class ExamplePage extends PageObject {
 *     }
 *   ```
 * PageObjects are created through Classes that extend one of the superClasses listed below:
 *
 * -----------------------
 *
 * @module ContainerObjects
 */
require("@testing/wdio-shadow-service");
const util_1 = require("util");
const async_sync_1 = require("../utils/async-sync");
/**
 * The present Class contains the base functionality that's inherited by all the others page
 * objects-type Classes, like [PageObjects](../pages/PageObject.md) or
 * [ComponentObjects](../components/ComponentObject.md).
 *
 * When extended directly in order to create the representation of a simple container,
 * the container's metadata must be provided via **[ContainerContext](ContainerContext.md)**
 * decorator.
 *
 *  ```typescript
 *    @ContainerContext({
 *        wrapper: 'text-container'
 *    })
 *    export class TextContainer extends ContainerObject {
 *    }
 *  ```
 *
 * -----------------------
 *
 */
class ContainerObject {
    /**
     * Time to wait for the DOM element representing the container to be loaded and ready to
     * be interacted.
     *
     * Its configuration can be customized via property `browser.config.timeouts.L`.
     */
    get timeout() {
        const config = browser.config;
        return (config.timeouts && config.timeouts.L) || 20000;
    }
    /**
     * This method should return true when the view or page loaded in the browser matches with
     * the *PageObject* instance active or, in other words, when the view or page represented by the
     * *PageObject* is the current page.
     *
     * The check is performed by comparing the page object's metadata defined via
     * [PageContext](../modules/PageContext.md) with the view or page loaded in the
     * application against which the tests are being executed.
     *
     * If you override this class remember to call `super.isCurrent()` to keep this behavior.
     *
     * ```ts
     *     import { PageObject, PageContext } from "@testing/wdio-page-objects";
     *
     *     @PageContext({
     *         wrapper: `#example`
     *     })
     *     export class ExamplePage extends PageObject {
     *     }
     *  ```
     *
     * --
     */
    isDisplayed() {
        if (!browser.isNativeApplication() && this.context.context !== "web")
            return false;
        const selectors = (util_1.isArray(this.context.selector) ? this.context.selector : this.context.selector ? [this.context.selector] : []);
        const elements = selectors.map(selector => $(selector));
        if (this.wrapper) {
            elements.unshift(this.wrapper);
        }
        const displayed = async_sync_1.parallel(...elements.map(element => () => {
            try {
                return element.isDisplayed();
            }
            catch (e) {
                return false;
            }
        }));
        return displayed.reduce((acc, disp) => disp && acc, true);
    }
}
exports.ContainerObject = ContainerObject;
/**
 * @hidden
 */
function isLoading(container) {
    const element$$ = container.wrapper ? container.wrapper.$$.bind(container.wrapper) : $$;
    if (!container.context.loadingIndicatorSelectors) {
        return false;
    }
    const elements = async_sync_1.parallel(...container.context.loadingIndicatorSelectors.map(s => () => element$$(s)))
        .reduce((acc, elements) => acc.concat(elements), []);
    return async_sync_1.parallel(...elements.map(e => () => e.isDisplayed())).reduce((acc, displayed) => acc || displayed, false);
}
exports.isLoading = isLoading;
/**
 * @hidden
 */
function ensureContext(container) {
    const ctx = util_1.isString(container) ? container : container.context.context;
    if (browser.isNativeApplication()) {
        ctx === 'web' ? browser.goWebContext() : browser.goNativeContext();
    }
}
exports.ensureContext = ensureContext;
//# sourceMappingURL=container.js.map