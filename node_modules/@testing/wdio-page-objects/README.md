## Wdio Page Objects

`Wdio-page-objects` is a framework that implements the page object pattern in order to encourage:

- To the scalability of your e2e testing project so, in the same way your application scales when it's extended with new functionality, your tests also scales in a structured manner bearing in mind,
    + on the one hand, the existence of pages or views with a given business logic and,
    + on the other hand, the existence of containers or components with encapsulated logic that contributes to fulfill with the [single responsability principle](https://hackernoon.com/understanding-solid-principles-in-javascript-w1cx3yrv).

- To the achivement of a more declarative code, so that the logic behind it's easier to follow.  

-----------------------

### Code structure

It's important to note that page objects start being instanciated from Cucumber Step Classes, which in turn are linked to the steps described in feature's scenarios. For this reason, down below we proceed to describe all the actors that can be part of the tests definition architecture.

---

#### \*.feature

Features consist of user-friendly descriptions of different scenarios given a particular navigation flow. Each scenario is composed by [steps](https://github.com/cucumber/cucumber-js/blob/main/docs/support_files/step_definitions.md), and each step is linked to actions resulting in interactions with DOM elements and assertions from these interactions determining whether a condition is fulfilled or not.

You can check [Cucumber](https://cucumber.io/docs/gherkin/reference/#feature) documentation for more info.

```txt
    @checkout
    Feature: CheckOut
    
    Scenario: Should get to chechout
    
        Given I'm a user with tags "user" [framework]
        And I'm in the "Ladies+Chrome+T-Shirt" product page of category "ladies_tshirts"
        When I add the product to the cart
        And I get to the shoping cart
        And I checkout
        And I fill in the user data
        And I place the order
        Then I should see a succeded confirmation message
```  

---

#### \*.steps.\*.ts

Steps are Cucumber glue classes, which have the purpose of linking the actions defined in Cucumber scenarios to the logic required for those actions −in the form of interaction with DOM elements− to get completed.

Instead of using Cucumber-like methods, Acis offers the possibility of grouping the steps in classes. This enables step reusing and also provides with an isolated context for step information sharing. Instances of those classes are singletons, created and destroyed for each scenario.  

```ts
    // (1) Cucumber-specific Objects
    import { When, World } from "@testing/cucumber-runner";

    import { CheckOutPage } from "./checkout.page";
    import { pageProvider } from "@testing/wdio-page-objects";
    import { User } from "../common/user";

    export class CheckoutSteps {
        world: World;
    
        constructor(world: World) {
          this.world = world;
        }
    
        @When('I fill in the user data')
        fillUserData() {
            // (2) pageProvider api
            pageProvider
                .wait(CheckOutPage)
                // (3) UserProvider api as part of Cucumber's World context
                .fillUserData(this.world.users.get().data as User);
        }
    
        @When('I place the order')
        placeOrder() {
            pageProvider.wait(CheckOutPage).placeOrder();
        }
    }
```  

> #### (1) Cucumber-specific Objects
> Steps contain the logic behind Gherkins descriptions. Check the **[Cucumber-runner](https://globaldevtools.bbva.com/bitbucket/projects/BGT/repos/e2e-js-framework/browse/packages/cucumber-runner/README.md)** package specification and the [CucumberJs](https://github.com/cucumber/cucumber-js) documentation to learn more.
> 
> #### (2) pageProvider api
> Logic behind steps is organized in page objects. **[pageProvider](docs/modules/PageProvider.md)** is the api that provides us with the necessary functionality to interact with page objects. It should be used from Step Classes only.
>
> #### (3) UserProvider api as part of Cucumber's World context
> Through the Cucumber's World context object it's possible to retrieve DataManager's users data via [UserProvider](https://globaldevtools.bbva.com/bitbucket/projects/BGT/repos/e2e-js-framework/browse/packages/base/docs/index.md) api.

---

#### \*.hooks.\*.ts

Cucumber hooks are functions fired in a specific stage of the Cucumber testing process' life cycle. Check [Cucumber](https://cucumber.io/docs/cucumber/api/#hooks) documentation for more info.

```ts
    import { Before } from "cucumber";

    // (1) Cucumber's "Before" hook
    Before(() => {
        if(!browser.isMobile) {
            try {
                browser.setWindowRect(10, 10, 400, 800);
            } catch(_) {
                browser.setWindowSize(400, 800);
                if(browser.isChrome) {
                    browser.setWindowPosition(10, 10);
                }
            }
        }
    });
```  

> #### (1) Cucumber's "Before" hook
> The anonymous function passed to "Before" is executed before each scenario.

---

#### \*.page.\*.ts

Page files contains PageObject-type classes, which represent a page or view in an application. They should be loaded from Step Classes only through the **[pageProvider](docs/modules/PageProvider.md)** api.

```ts
    import { PageObject, PageContext } from "@testing/wdio-page-objects";
    import { User } from "../common/user";
    import { expect } from "chai";
    
    // (1) PageContext declaration
    @PageContext({
        path: '/checkout',
        wrapper: `shop-app[page=checkout]`,
        selector: [`#accountEmail`]
    })
    // (2) Pages must extend from PageObject
    export class CheckOutPage extends PageObject {
    
        placeOrder() {
            $(`#submitBox input`).click();
        }
    
        fillUserData(user: User) {
            const prevOptions = browser.safeMode();
            browser.safeMode({notAnimating: false, scrollIntoView: true});
    
            $(`#accountEmail`).setValue(user.email);
            $(`#accountPhone`).setValue(user.phone);
            $(`#shipAddress`).setValue(user.address.street);
    
            browser.safeMode(prevOptions);
        }
    }
```  

> #### (1) PageContext declaration
> **[PageContext](docs/modules/PageContext.md)** - Page registry based in decorators.
> 
> #### (2) Pages must extend from PageObject
> **[PageObject](docs/classes/PageObjects.Page.md)** - Page objects must extend the PageObject class in order to be recognized as such.
>
> Apart from PageObjects, pages can also extend from:
>
> **[ErrorPage](docs/classes/PageObjects.ErrorPage.md)** - Special Class extending from PageObject that exposes an abstract method to be implemented when the reference context for a page is not found and we'd like to return a message with the error details.  
>
> **[DiscardablePage](docs/classes/PageObjects.DiscardablePage.md)** - Special Class extending from PageObject that exposes an abstract method to be implemented when a specific view or web content may radomly appear so, we need to be prepared to exit that view or web content in order to continue with the target navigation flow being tested.

---

#### \*.component\*.ts

Component files contain ComponentObject-type classes, which represent a web component in an application's view or page. They should be loaded from Steps or PageObject Classes only through the **[componentProvider](docs/modules/ComponentProvider.md)** api.

```ts
    import { containerProvider, ComponentObject, parallel } from "@testing/wdio-page-objects"
    import { MessageContainer } from "./message.component";
    
    // (1) ComponentContext declaration
    ComponentContext({
        wrapper: '.component1',
        selector: ['.text', '.text-content']
    })
    // (2) Pages must extend from ComponentObject
    export class ExampleComponent extends ComponentObject {

        getMessage(): string {
            return parallel(...containerProvider
                .findMany(MessageContainer)
                .map(c => () => c.message))
                .join(',');
        }
    }
```  

> #### (1) ComponentContext declaration
> **[ComponentContext](docs/modules/ComponentContext.md)** - Component registry based in decorators.
> 
> #### (2) Components must extend from ComponentObject
> **[ComponentObject](docs/modules/components_component.md)** - Component objects must extend the ComponentObject class in order to be recognized as such.

---

#### \*.co\*.ts

Container files contain ContainerObject-type classes, which represent a DOM element that not necessarily it's part of any web component. They can be imported from Steps, PageObject or ComponentObject Classes through the [containerProvider](docs/modules/ContainerProvider.md) api.

Containers represents the pyramidal base for page objects: componentObjects and pageObjects inherit functionality from them.  

```ts
    import { ContainerObject, ContainerContext } from "@testing/wdio-page-objects"

    // (1) ContainerContext declaration
    @ContainerContext({
        wrapper: '.text'
    })
    // (2) Pages must extend from ContainerObject
    export class MessageContainer extends ContainerObject {
    
        get message() {
            return $('.text-content').getText();
        }
    }
```  

> #### (1) ContainerContext declaration
> **[ContainerContext](docs/modules/containers_containerContext.md)** - Container registry based in decorators.
> 
> #### (2) Containers must extend from ContainerObject
> **[ContainerObject](docs/modules/containers_container.md)** - Containers objects must extend the ContainerObject class in order to be recognized as such.

---

Did this documentation fullfilled your expectations? If you miss something, [let us know](mailto:testing.global.group@bbva.com)!