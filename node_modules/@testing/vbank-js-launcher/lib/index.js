const spawn = require('child_process').spawn;
const fs = require('fs');

module.exports = class VBankLauncher {
    constructor() {}

    getBinaryPath() {
        return __dirname + '/../bin/vbank-cloud-boot.jar';
    }
    
    getNettyContextAgent() {
        return __dirname + '/../bin/netty-context-agent.jar';
    }

    buildOptions({
        logFile = undefined,
        timeout = 25000,
        backends = [],
        workspace = '.',
        recording = false,
        args = [],
        verbose = false,
        ssl = {},
        proxy = {}
    }) {
        this.logFile = logFile;
        this.timeout = timeout;
        
        const { certificates, privateKey } = ssl;
        const options = [
        	'-javaagent:' + this.getNettyContextAgent(),
            '-jar', '-Dfile.encoding=UTF-8', this.getBinaryPath(),
            '-w', workspace,
        ];

        if (verbose) {
            options.push('-v');
        }

        if (recording) {
            options.push('-r');
        }

        if (certificates && privateKey) {
            options.push('-c', certificates.toString());
            options.push('-k', privateKey);
        }

        backends.forEach(backend => {
            // -b <name>=<protocol>:<port[:<sslEnabled>]>
            options.push('-b', `${backend.name}=${backend.protocol}:${backend.port}`);

            if (backend.cors) {
                options.push(`--http-cors=${backend.name}=headers:${(backend.cors.headers || []).join(',')};methods:${(backend.cors.methods || []).join(',')}`);
            }

            if (backend.realUrl) {
                options.push('-B', `${backend.name}=${backend.realUrl}`);
            }

            if (backend.sessionLocator) {
                (Array.isArray(backend.sessionLocator) ? backend.sessionLocator : [backend.sessionLocator])
                    .forEach(sl => options.push('-bsl', `${backend.name}=${sl}`));
            }

            if (backend.sessionInjector) {
                (Array.isArray(backend.sessionInjector) ? backend.sessionInjector : [backend.sessionInjector])
                    .forEach(si => options.push('-ibsl', `${backend.name}=${si}`));
            }
        });

        const { type, port } = proxy;
        if (type && port) {
            // -t <proxyType>:<proxyPort>
            options.push('-t', `${proxyPort}:${proxyPort}`);
        }

        return options.concat(args);

    }

    async start(args) {
        const options = this.buildOptions(args);

        console.log("[vbank] starting with: java ", options.join(' '))

        this.proc = spawn('java', options, {
            stdio: 'pipe',
            detached: false
        });

        console.log("[vbank] process started");

        if (this.logFile) {
            this.proc.stdout.pipe(fs.createWriteStream(this.logFile, {flags:'a'}));
            this.proc.stderr.pipe(fs.createWriteStream(this.logFile, {flags:'a'}));
        }

        this.proc.unref();

        process.on('exit', () => {
            this.stop();
        });

        return new Promise((resolve, reject) => {
            const timeoutRef = setTimeout(async () => {
                await this.stop();
                reject("[vbank] Error starting vbank: Didn't see ready message. Timeout");
            }, this.timeout);
            timeoutRef.unref();
            let data = " ";

            this.proc.stdout.on("data", (chunk) => {
                data = data && data + chunk;
                if(!this.logFile) {
                    console.log(chunk.toString());
                }
                if(data && data.indexOf("Starting service listener on port ") > 0)  {
                    console.log("[vbank] ready");
                    clearTimeout(timeoutRef);
                    data = undefined;
                    resolve();
                }
            });
        });
    }

    async stop() {
        console.log("[vbank] process finished");
        this.proc.kill();
    }
}