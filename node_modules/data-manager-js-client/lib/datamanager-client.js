"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataManagerConfig = exports.DataDecryptionError = exports.DataLockedError = exports.NoDataError = exports.MultipleDataManagerQuery = exports.DataManagerQuery = exports.MultipleDataEntryResult = exports.DataEntryResult = exports.DataManager = exports.LockTypes = exports.DataEntry = void 0;
const HttpClientImpl_1 = require("./http/HttpClientImpl");
const crypto = require("crypto");
const ENCRYPTED_PATTERN = /\$([^\:]+):(.+)/;
/**
 * Data entry containing data provided by the data manager
 * @property {string} id
 * @property {tags: string[], [key: string]: any} data data returned by the data manager
 * @property {Date | string} lockExpiration date when the lock expires
 * @property {string} lockType either 'exclusive' or 'shared'
 */
class DataEntry {
}
exports.DataEntry = DataEntry;
exports.LockTypes = {
    SHARED: 0,
    EXCLUSIVE: 1
};
/**
 * Data manager client class
 * Will use the configuration object provided, but it will
 * fallback to environment variables if avail as follows:
 * - baseUrl: process.env.DATAMANAGER_BASE_URL
 * - headers: JSON.parse(process.env.DATAMANAGER_HEADERS)
 * - timeout: process.env.DATAMANAGER_TIMEOUT
 * - withCredentials: process.env.WITH_CRENDENTIALS
 * - auth.username: process.env.DATAMANAGER_AUTH_USERNAME
 * - auth.password: process.env.DATAMANAGER_AUTH_PASSWORD
 * - maxRedirects: process.env.DATAMANAGER_MAX_REDIRECTS
 * - proxy: process.env.DATAMANAGER_PROXY
 * @param {DataManagerConfig} [config]
 */
class DataManager {
    constructor(config) {
        this.lockRefreshing = {};
        // Bootstrap our own processor
        const envConfig = {
            baseUrl: process.env.DATAMANAGER_BASE_URL,
            headers: process.env.DATAMANAGER_HEADERS &&
                JSON.parse(process.env.DATAMANAGER_HEADERS),
            timeout: parseInt(process.env.DATAMANAGER_TIMEOUT) || 20000,
            withCredentials: process.env.WITH_CRENDENTIALS === 'true',
            auth: process.env.DATAMANAGER_AUTH_USERNAME && {
                username: process.env.DATAMANAGER_AUTH_USERNAME,
                password: process.env.DATAMANAGER_AUTH_PASSWORD
            },
            lockAttempts: process.env.DATAMANAGER_LOCK_ATTEMPTS
                && parseInt(process.env.DATAMANAGER_LOCK_ATTEMPTS),
            lockAttemptsInterval: process.env.DATAMANAGER_LOCK_ATTEMPTS_INTERVAL
                && parseInt(process.env.DATAMANAGER_LOCK_ATTEMPTS_INTERVAL),
            maxRedirects: parseInt(process.env.DATAMANAGER_MAX_REDIRECTS) || undefined,
            proxy: process.env.DATAMANAGER_PROXY,
            encryptionKey: process.env.ENCRYPTION_KEY && crypto.createHash("sha256").update(process.env.ENCRYPTION_KEY).digest()
        };
        Object.keys(envConfig).forEach(k => {
            if (envConfig[k] === undefined) {
                delete envConfig[k];
            }
        });
        this.headers = Object.assign(Object.assign({}, (config || {}).headers), envConfig.headers);
        this.config = Object.assign({}, { timeout: 4000, lockAttempts: 2 }, config, envConfig);
        this.client = new HttpClientImpl_1.default(this.config);
    }
    /**
     * Locks the data entry with the indicated id.
     * @param {string} id
     * @param {boolean} exclusive if should be locked in exclusive mode
     * @returns {Promise}
     */
    lock(id, exclusive) {
        let timeout = 2 * (parseInt(process.env.DATAMANAGER_LOCK_TIMEOUT) || 30);
        const type = exclusive ? 'EXCLUSIVE' : 'SHARED';
        return this.client.post(`${id}/locks`, { type: type, timeout: 1 }, this.getDynamicConfig())
            .then((result) => {
            const lockId = result.data && result.data.id;
            const refresh = (first = false) => {
                if (!first) {
                    this.client.patch(`${id}/locks/${lockId}`, { timeout: 1 }, this.getDynamicConfig());
                }
                if (timeout--) {
                    this.lockRefreshing[lockId] = setTimeout(() => refresh(), 30000);
                    this.lockRefreshing[lockId].unref();
                }
                else {
                    delete this.lockRefreshing[lockId];
                }
            };
            refresh(true);
            return result;
        });
    }
    /**
     * Removes the lock in the provided data entry
     * @param {string} id the id of the data entry
     * @param {string} lockid the id of the lock
     * @returns {Promise}
     */
    unlock(id, lockid) {
        clearTimeout(this.lockRefreshing[lockid]);
        return this.client.delete(`${id}/locks/${lockid}`, this.getDynamicConfig());
    }
    /**
     * Removes the lock and tags in the provided data entry
     * @param {string} id the id of the data entry
     * @param {string} lockid the id of the lock
     * @param {array} tags the list of tags to burn of the data entry
     * @returns {Promise}
     */
    unlockAndBurnData(id, lockid, tags) {
        clearTimeout(this.lockRefreshing[lockid]);
        return this.client.post(`${id}/locks/${lockid}/burn`, { tags }, this.getDynamicConfig());
    }
    /**
     * Find a single data entry
     * @param  {DataManagerQuery} query
     * @returns {Promise<DataEntryResult>}
     */
    async findOne(query) {
        let data = await this.findOneOrRetry(query);
        let plane = await this.decrypt(data.data, data.id, data.lock);
        return Object.assign(Object.assign({}, data), { data: Object.assign({}, plane) });
    }
    async decrypt(entry, dataId, lockId) {
        let decrypt = entry;
        if (typeof entry === 'object') {
            for (let item in decrypt) {
                decrypt[item] = await this.decrypt(decrypt[item], dataId, lockId);
            }
        }
        else {
            return this.singleDecrypt(decrypt, dataId, lockId);
        }
        return decrypt;
    }
    async singleDecrypt(data, dataId, lockId) {
        const groups = ENCRYPTED_PATTERN.exec(data);
        if (groups && groups.length) {
            if (this.config.encryptionKey) {
                const [encrypted, hash] = [Buffer.from(groups[1], 'base64'), Buffer.from(groups[2], 'base64')];
                const decipher = crypto.createDecipheriv("aes-256-ecb", this.config.encryptionKey, '');
                let raw = Buffer.concat([decipher.update(encrypted), decipher.final()]);
                if (crypto.createHash("sha256").update(raw).digest().toString('hex') !== hash.toString('hex')) {
                    await this.unlock(dataId, lockId);
                    throw new DataDecryptionError('Provided credentials cannot be used to decode given data');
                }
                return raw.toString('utf8');
            }
            else {
                await this.unlock(dataId, lockId);
                throw new DataDecryptionError(`ENCRYPTION_KEY env variable must be provided with encrypted data`);
            }
        }
        else {
            return data;
        }
    }
    async findOneOrRetry(query, attempt = 0) {
        let isExclusive = query.lock === true;
        let params;
        if (query.tags && query.tags.length > 0) {
            params = Object.assign({ 'tags[]': query.tags.join() }, query);
            delete params.tags;
        }
        else {
            params = query;
        }
        let response = await this.client.get('', Object.assign({ qs: params }, this.getDynamicConfig()));
        let items = response && response.data;
        //TODO: removed this behaviour to make it deterministic for vbank to record. Review.
        //this.shuffle(items);
        if (items && items.length) {
            if (!Array.isArray(items)) {
                throw new Error('Invalid response from server ' + JSON.stringify(response));
            }
            //We give priority to the shared entries
            items.sort(a => a.lockType ? -1 : 1);
            // If it's not exclusive then we can also take a shared one...
            let item = items.find(i => isExclusive ? !i.lockType : !i.lockType || i.lockType === 'SHARED');
            if (item) {
                try {
                    let lock = await this.lock(item.id, isExclusive);
                    return { id: item.id, data: item.data, lock: lock.data.id };
                }
                catch (error) {
                    if (!error.response || error.response.status !== 409) {
                        throw error;
                    }
                }
            }
            if (this.config.lockAttempts && attempt < this.config.lockAttempts) {
                console.log('No free items found.... retrying');
                await new Promise(resolve => setTimeout(resolve, this.config.lockAttemptsInterval || 30000));
                return this.findOneOrRetry(query, attempt + 1);
            }
            else {
                throw new DataLockedError('Some items were found but they are locked right now.');
            }
        }
        throw new NoDataError('No data has been found for query.');
    }
    /**
     * Finds and locks multiple data entries by key
     * @param {MultipleDataManagerQuery} query
     * @returns {Promise<MultipleDataEntryResult>}
     */
    async findMultiple(query) {
        let keys = Object.keys(query);
        let promises = keys.map(k => this.findOne(query[k]));
        let result = {};
        let done = 0;
        let error;
        await new Promise(res => {
            promises.forEach((p, i) => {
                p.then(data => result[keys[i]] = data)
                    .catch(reason => error = reason)
                    .then(() => (++done >= keys.length) && res(undefined));
            });
        });
        if (error) {
            await Promise.all(Object.keys(result).map(k => result[k] && this.unlock(result[k].id, result[k].lock)));
            throw error;
        }
        return result;
    }
    getDynamicConfig() {
        return {
            headers: Object.assign(Object.assign({}, this.headers), global.dataManagerHeaders)
        };
    }
}
exports.DataManager = DataManager;
/**
 * DataEntry result. Represents a reserved data entry in the data-manager.
 * @property {string} id
 * @property {any} data
 * @property {string} lock the id of the lock entry
 */
class DataEntryResult {
}
exports.DataEntryResult = DataEntryResult;
/**
 * Multiple data entry result. Map containing the results per requested
 * key
 * @extends { [key: string]: DataEntryResult }
 */
class MultipleDataEntryResult {
}
exports.MultipleDataEntryResult = MultipleDataEntryResult;
/**
 * Data manager query
 * @property {string[]} tags tags that the data provided must fullfil
 * @property {boolean} lock indicates if the lock over the data should be exclusive
 */
class DataManagerQuery {
}
exports.DataManagerQuery = DataManagerQuery;
/**
 * Map of querys by requested key
 * @extends {[key: string]: DataManagerQuery}
 */
class MultipleDataManagerQuery {
}
exports.MultipleDataManagerQuery = MultipleDataManagerQuery;
class NoDataError extends Error {
}
exports.NoDataError = NoDataError;
class DataLockedError extends Error {
}
exports.DataLockedError = DataLockedError;
class DataDecryptionError extends Error {
}
exports.DataDecryptionError = DataDecryptionError;
/**
 * Data manager config
 * @property {string} baseUrl
 * @property {Map<string,string>} headers
 * @property {number} timeout in miliseconds
 * @property {boolean} withCredentials
 * @property auth
 * @property {number} maxRedirects
 * @property {string} proxy
 **/
class DataManagerConfig {
}
exports.DataManagerConfig = DataManagerConfig;
